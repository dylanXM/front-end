## 操作系统的四个特征

1. 并发：同一时间段内多个程序执行（并行是同一时刻的多个事件，并发誓同一时间段内的多个事件）
2. 共享：系统中的资源可以被多个并发执行的进线程共同享用
3. 虚拟：通过时分复用（如分时系统）和空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个
4. 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进

## 进程与线程

### 多进程的组织形式

1. `PCB`(`Process Control Block`)用来记录进程信息的数据结构（管理进程的核心，包含了PID等进程的所有关键信息）
2. 进程的状态：就绪状态、执行状态、阻塞状态（多线程时也是这些状态）
3. 队列：就绪队列、等待（阻塞）队列

![img](https://images2018.cnblogs.com/blog/1169376/201807/1169376-20180710220802379-2085911867.png)

处于就绪状态的进程，在调度程序为之分配了处理机之后便开始执行，**就绪 -> 执行**

正在执行的进程如果因为分配它的时间片已经用完，而被剥夺处理机，**执行 -> 就绪**

如果因为某种原因致使当前的进程执行受阻，使之不能执行               **执行 -> 阻塞**

### CPU调度算法（在就绪序列中怎么挑选进程让CPU执行）

- 周转时间：从开始申请执行任务，到执行任务完成
- 响应时间：从开始申请执行任务到开始执行任务

**先来先服务调度算法FCFS**：按作业或进程达到的先后顺序依次调度；（平均周转时间可能会很长）

**短作业优先调度算法SJF**：算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行（周转时间短，但是响应时间长）

**高响应比算法HRN**：响应比=（等待时间 + 要求服务时间） / 要求服务时间

**时间片轮转调度RR**：按到达的先后将进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环；（响应时间得到保证）

**多级反馈队列调度算法**：设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按**先来先服务调度算法**放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部...。只有当前一个队列为空的时候才会调度下一个队列的进程

### 进程的分类（未完成）

[进程分类](**https://www.cnblogs.com/xdyixia/p/9257160.html**)：僵尸进程、孤儿进程、守护进程

### 线程

线程有自己的`TCB`（`Thread Control Block`，线程控制块），只负责这条流程的信息，包括PC程序计数器，SP栈，State状态和寄存器，线程ID

线程有**内核级线程**和**用户级线程**

- 只有内核级线程才能发挥多核性能，因为内核级线程共用一套`MMU`（即**内存映射表**），统一分配核1核2（即有多个CPU，可以一个CPU执行一个内核级线程）。进程无法发挥多核性能，因为进程切换都得切`MMU`
- 为什么需要内核级线程？如果只有用户级线程，在内核中只能看到进程，所以当用户级线程中一个进程进行IO读写阻塞时，内核会将该线程所在的进程直接切换。例如当用浏览器打开网页，这个进程中有下载数据线程、有显示数据线程，当数据下载读写阻塞时，内核直接切到qq（这些切换是指在CPU上运行的程序的切换）

 ![img](https://bkimg.cdn.bcebos.com/pic/8326cffc1e178a82dcc0d00af503738da877e898?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg) 

### 进程和线程的对比

**进程是系统进行资源调度和分配的基本单位；线程是CPU调度的基本单位**

进程

- 资源（包括寄存器值，PCB，内存映射表） + TCB（栈结构）
- 资源分隔独立，内存映射表不同，占用物理内存地址是分隔的
- 进程的切换切换资源，即切换内存映射表

线程

- TCB（栈结构）
- 资源是共享的
- 切换了TCB

### 进程间的通信方式

- 管道(PIPE)：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
- 命名管道(FIFO)：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
- 信号(signal)：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身。
- 消息队列(MessageQueue)：有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺限。
- 共享内存(SharedMemory)：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
- 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
- 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
- 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。

### 进程间的同步

经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题

同步的解决方案：管程，信号量

**死锁**

- 定义：在两个或多个并发进程中，如果每个进程持有某种资源而又等待别的进程释放它或它们所持有的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。就是两个或多个进程被无限期阻塞、相互等待的一种状态
- 产生条件：
  - 互斥条件：一个资源一次只能被一个进程使用
  - 请求保持条件：一个进程因请求资源而阻塞时，对已经获得资源保持不放
  - 不可抢占条件：进程已获得的资源在未使用完之前不能强行剥夺
  - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系
- 死锁处理：
  - 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；但是如果限制过于严格的话会降低系统资源利用率以及吞吐量
  - 避免死锁：在资源的动态分配中，防止系统进入不安全的状态（可能产生死锁的状态）-如银行家算法
  - 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 
  - 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，解放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大
- 死锁忽略： windows，Linux个人版都不做死锁处理，直接忽略，大不了重启就好了，小概率事件，代价可以接受

## 内存管理

### 要解决的两个问题

1. 每个进程代码中使用的地址可能相同。**解决思路**：对代码中的地址重定向（加个基地址）
2. 物理内存可能比较小，不能同时放很多进程进来。**解决思路**：把要运行的代码移到内存，暂时不用的代码移入磁盘，即交换（swap），内存置换

### 分段

一个程序分成多个段（每个段特性不同为了方便管理，例如代码段只读、数据段等等），当然这都是逻辑上的。

管理段的结构叫段表，段表保存在进程的PCB中

![img](https://images2018.cnblogs.com/blog/1169376/201807/1169376-20180711102655465-1407008790.png)

### 页表

把程序按段分对程序员是友好的，但是如果物理存储也按段存则会导致大块的内存碎片，例如现在需要分个10M的段但是连续的存储空间只有8M/9M/5M三个。**解决方法**：（将段打散存到页中）不要对内存进行连续的内存，将内存会分为1页1页，按页分配，1页4KB大小，最多也就浪费4KB。这样不会有内存碎片，也不会出现没有符合要求大小的内存可以申请的情况，因为可以打散了分散到一页一页中。



、

