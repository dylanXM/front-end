## 比较排序的时间复杂度为什么最小为`nloh(n)`

a1, a2, a3,...an序列的所有排序有n!种，所以满足要求的排序a1', a2', a3',...an'（其中a1' <= a2' <= a3' <= ... <= an'）的概率为`1/n!`。基于输入元素的比较排序，每一次比较的返回不是0就是1，这恰好可以作为决策树的一个决策将一个事件分成两个分支。比如冒泡排序时通过比较a1和a2两个数的大小可以把序列分成a1, a2,...an和a2, a1,...an（气泡a2上升一个身位）两种不同的结果，因此比较排序也可以也可以构造决策树。根节点代表原始序列a1, a2, a3, ...an，所有叶子节点都是这个序列的重排（共有n!个，其中有一个就是我们排序的结果a1', a2', a3',...an'）。如果每次比较的结果都是等概率的话（恰好划分为概率空间相等的两个事件），那么二叉树是高度平衡的，深度至少是`log(n!)`

- `n! <= n^n`，两边取对数就得到`log(n!) <= log(n ^ n)`，所以`log(n!) = O(nlogn)`
- `n! = n(n-1)(n-2)...1 >= (n/2)^(n/2)`，两边取对数得到`log(n!) > (n/2)log(n/2)`，所以`log(n!) = Θ(nlogn)`

因此`log(n!)`的增长速度和`nlogn`相同，即`log(n!) = O(nlogn)`。

## 排序的稳定性和复杂度

|  排序算法  |                      时间复杂度                      | 是否稳定 |
| :--------: | :--------------------------------------------------: | :------: |
|  选择排序  |                        O(n^2)                        |  不稳定  |
|  快速排序  |          O(nlogn) 平均时间, O(n^2) 最坏情况          |  不稳定  |
|   堆排序   |                       O(nlogn)                       |  不稳定  |
|  希尔排序  |                       O(nlogn)                       |  不稳定  |
|  基数排序  |    O(n·k)；需要 O(n) 额外存储空间 （K为特征个数）    |  不稳定  |
|  插入排序  |                        O(n^2)                        |   稳定   |
|  冒泡排序  |                        O(n^2)                        |   稳定   |
|  归并排序  |           O(nlogn)；需要 O(n) 额外存储空间           |   稳定   |
| 二叉树排序 |           O(nlogn)；需要 O(n) 额外存储空间           |   稳定   |
|  计数排序  | O(n+k); 需要 O(n+k) 额外存储空间，k为序列中Max-Min+1 |   稳定   |
|   桶排序   |             O(n); 需要 O(k) 额外存储空间             |   稳定   |

**稳定性**： 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 

**稳定性是不变的吗**？

 对于不稳定的[排序算法](https://baike.baidu.com/item/排序算法)，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。**需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。 **

**稳定性的意义**

1. 如果只是简单的进行数字的排序，那么稳定性将毫无意义。
2. 如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义
3. 如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。
4. 除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）
5. 换句话说，以某种关键字的方式排序后，能不影响到其他关键字原来排序结果的方法就是稳定的，比如一开始按照价格高低排序结果为 a(10元，卖了5个) b(8元，卖了20个) c(6元，卖了20个) d(4元，卖了30个),则按照销量重拍后如果保持 d(30个,价格为4元) b(20个，价格为8元) c(20个，价格为6元) a(5个，价格为10元)，则说明该方法为稳定的，而如果出现c在b前，破坏了排序前b在c前的顺序，则说明这个方法是不稳定的

## 每种排序的原理和实现

### 插入排序

遍历数组，遍历到第`i`个元素时，a0, a1,...ai-1 是已经排好序的，取出ai，从ai-1开始向前和每个元素比较大小，如果小于，浙江此位置元素向后移动，继续先前比较；如果不小于，则放到正在比较的元素之后。**可见相等元素比较时，原来靠后的还是排在后面，所以插入排序是稳定的。**

当待排序的数据基本有序时，插入排序的效率比较高，只需要进行很少的数据移动

```js
let insertSort = nums => {
    let len = nums.length;
    let i, j;
    for(i = 1; i < len; i++){
        let v = nums[i];
        for(j = i - 1; j >= 0 && v < nums[j]; j--){
        	nums[j + 1] = nums[j];   
        }
        nums[j + 1] = v;
    }
    return nums;
}
```

### 选择排序

遍历数组，遍历到第i个元素时，a0, a1,...ai -1是已经排好序的，然后从i到n选出最小的，记录下位置，如果不是第i个，则和第i个元素交换。**此时第i个元素可能会排到相等元素之后，造成排序的不稳定**

```js
let selectSort = nums => {
    let len = nums.length;
    let i, j, pos, tmp;
    for(i = 0; i < len - 1; i++){
        //寻找元素最小的下标
        pos = i;
        for(j = i + 1; j < len; j++){
            if(nums[j] < nums[i]){
                pos = j;
            }
        }
        if(pos != i){
            tmp = nums[pos];
            nums[pos] = nums[i];
            nums[i] = tmp;
        }
    }
    return nums;
}
```

### 冒泡排序

冒泡排序的名字很形象，实际实现是相邻两节点进行比较，大的向后移一个，经过第一轮的两两比较和移动，最大元素移动到了最后，第二轮次大的元素位于倒数第二个，依次进行。

**优化一：**如果某一轮两两比较中没有任何元素交换，这说明已经都排好序了，算法结束，可以使用一个Flag做标记，默认为false，如果发生交互则置为true，每轮结束时检测flag，如果为true则继续，如果为false则返回。

**优化二（待定）：**某一轮结束位置为j，但是这一轮的最后一次交换发生在lastSwap的位置，则lastSwap到j之间是排好序的，下一轮的结束点就不必是j--了，而直接到lastSwap即可。

```js
var bubbleSort = function(nums){
            let i, j;
            let len = nums.length;
            for(let i = len - 1; i >= 0; i--){
                for(let j = 0; j < i; j++){
                    if(nums[j] > nums[j + 1]){
                        let temp = nums[j];
                        nums[j] = nums[j + 1];
                        nums[j + 1] = temp;
                    }
                }
            }

            return nums;
        }
```

### 快速排序

快速排序是先找到一个基准，例如以第一个元素作为基准，然后先从右向左搜索，如果发现比基准小，则和基准交换；然后再从左向右搜索，如果发现比基准大，则和基准交换。一直到基准左边的元素都比基准小，基准右边的元素都比基准大。此时基准的位置就是排好序后应该在的位置。

```js
var getIndex = function(nums, left, right){
    let p = nums[left];
    while(left < right){
        while(left < right && nums[right] > p) right--;
        if(left < right) nums[left++] = nums[right];
        while(left < right && nums[left] < p) left++;
        if(left < right) nums[right--] = nums[left];
    }
    nums[left] = p;
    return left;
}

var qSort = function(nums, left, right){
    if(left < right){
        var index = getIndex(nums, left, right);
        qSort(nums, left, index - 1);
        qSort(nums, index + 1, right);
    }
}
```

### 堆排序

堆排序是把数组看成堆，第`i`个节点的孩子是第`2*i+1`和`2*i+2`个节点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆元素后再调整堆。建堆的过程是自底向上不断调整建成的，这样当调整某个节点时，其左节点和右节点已经是满足条件的，此时如果两个子节点不需要动，则整个子树不需要动，如果调整，则父节点交换到子节点位置，再以此节点继续调整

下面代码使用的大顶堆，建立好堆后堆顶的元素为最大值，此时取堆顶元素和最后一个元素交换，最大的元素处于数组最后，此时调整小了一个长度的堆，然后再取堆顶和倒数第二个元素交换，依次类推，完成数据的非递减排序

堆排序的主要时间花在初始建堆期间，建好堆后，堆这种数据结构以及它奇妙的特征，使得找数列中最大的数字这样的操作只需要o(1)的时间复杂度，维护需要o(logn)的时间复杂度，堆排序不适宜记录数较少的文件

```js
var heapAdjust = function(nums, i, length){
            let nChild;
            for(let nTmp = nums[i]; 2 * i + 1 < length; i = nChild){
                nChild = 2 * i + 1;
                if(nChild + 1 < length && nums[nChild] < nums[nChild + 1])
                    nChild++;
                if(nTmp < nums[nChild]){
                    nums[i] = nums[nChild];
                    nums[nChild] = nTmp;
                }
                else break;
            }
        }

        var heapSort = function(nums){
            let len = nums.length;
            for(let i = len / 2 - 1; i >= 0; i--){
                heapAdjust(nums, i, len);
            }

            for(let i = len - 1; i > 0; i--){
                let tmp = nums[0];
                nums[0] = nums[i];
                nums[i] = tmp;
                heapAdjust(nums, 0, i);
            }
        }
```

### 归并排序

归并排序是采用分治法的一个典型应用，首先考虑一下如何将两个有序数列合并，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应的数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次去除即可。这需要将待排序列中的所有记录扫描一遍，因此需要耗费O(n)时间，而由二叉树的深度可知，这个归并序列需要进行logn次，因此，总的时间复杂度为O(nlogn)。

归并排序在过程中需要与原始记录序列数量的存储空间存放归并结果，因此空间复杂度为O(n)

归并算法需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法

```js
var mergeArray = function(nums, first, mid, last, tmp){
            let i = first, j = mid + 1;
            let m = mid, n = last;
            let k = 0;

            while(i <= m && j <= n){
                if(nums[i] <= nums[j]){
                    tmp[k++] = nums[i++];
                }else{
                    tmp[k++] = nums[j++];
                }
            }

            while(i <= m) tmp[k++] = nums[i++];
            while(j <= n) tmp[k++] = nums[j++];

            for(i = 0; i < k; i++){
                nums[first + i] = tmp[i];
            }
        }

        var mergeSort = function(nums, left, right, tmp){
            if(left < right){
                let mid = parseInt((left + right) / 2);
                mergeSort(nums, left, mid, tmp);
                mergeSort(nums, mid + 1, right, tmp);
                mergeArray(nums, left, mid, right, tmp);
            } 
        }
```

### 希尔排序

希尔排序是对插入排序的优化，基于以下两个认识：

- 数据量较小时插入排序比较快，因为n和n^2差距很小
- 数据基本有序时插入效率很高，因为比较和移动的数量很少

因此希尔排序的基本思想是将需要排序的序列划分成为若干个较小的子序列，对子序列进行插入排序，通过插入排序能够使原本序列成为基本有序。 这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。

希尔排序的划分子序列不是像归并排序那种的二分，而是采用的叫做增量的技术，例如有十个元素的数组进行希尔排序，首先选择增量为10/2=5，此时第1个元素和第（1+5）个元素配对成子序列使用插入排序进行排序，第2和（2+5）个元素组成子序列，完成后增量继续减半为2，此时第1个元素、第（1+2）、第（1+4）、第（1+6）、第（1+8）个元素组成子序列进行插入排序。这种增量选择方法的好处是可以使数组整体均匀有序，尽可能的减少比较和移动的次数，二分法中即使前一半数据有序，后一半中如果有比较小的数据，还是会造成大量的比较和移动，因此这种增量的方法和插入排序的配合更佳。 

 希尔排序的时间复杂度和增量的选择策略有关，上述增量方法造成希尔排序的不稳定性。 

![img](https://images0.cnblogs.com/blog/472287/201311/30100201-172475e3a73a4e21a7f70390ff0742f6.jpg)

```js
var shellSort = function(nums){
            let len = nums.length;
            let i, j, d, tmp;                                          //d为增量
            for(d = parseInt(len / 2); d >= 1; d = parseInt(d / 2)){   //增量递减到1时完成排序
                for(i = d; i < len; i++){                              //插入排序的一轮
                    tmp = nums[i];
                    for(j = i - d; j >= 0 && nums[j] > tmp; j = j - d){
                        nums[j + d] = nums[j];
                    }
                    nums[j + d] = tmp;
                }
            }
        }
```

