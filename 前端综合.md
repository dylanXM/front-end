# 前端综合

### 怎么看待前端开发？怎么看待前端工程师？前端的价值体现在哪？

- 前端工程师是将想法变成产品展示给用户的职位
- 前端工程师是最接近用户的开发工程师，可以提供给用户浏览器兼容支持，提供用户与产品的交互支持
- 前端工程师的价值体现在能够解决其他工程师解决不了的问题（这对于任何工程师职位都是成立的）。比如用户想要在PC端、ios、android、pad和tv端使用，怎样才能让用户操作方便；怎样才能让低宽带网络不显得太慢；怎样才能在不稳定连接时假装还能继续服务；

### 什么样的代码是好的代码

- 代码是可工作的
- 代码是可读性高的
- 代码是易维护的
- 代码是高内聚低耦合的
- 代码应该是用更短的时间更小的内存

### 前端需要注意哪些SEO？

- 合理的 `title`,  `description`, `keywords`: 搜索对这三项的权重逐个减小，`title`值强调重点即可，重要关键词不要出现超过2次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面的`description`有所不同；`keywords`列举出重要关键词即可
- 语义化的`HTML`代码，符合W3C规范：语义化的代码让搜索引擎更容易理解网页
- 重要内容`HTML`代码放在前面：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用`js`输出：爬虫不执行`js`获取内容
- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度：网站速度是搜索引擎的一个重要指标

### 如何对网站性能进行优化

- `content`方面
  - 减少`HTTP`请求：合并文件、`cssSprites`
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名

  - 减少`DOM`元素数量

- `Server`方面
  - 使用`CDN`
    
  - 配置`ETag`
    
  - 对组件使用`Gzip`压缩

- `Cookie`方面
  - 减少`cookie`大小

- `css`方面
  - 将样式表放到页面顶部
    
  - 不使用`css`表达式
    
  - 使用`<link>`不使用`@import`

- `Javascript`方面
  - 将脚本放在页面底部
    
  - 将`javascript`和`css`从外部引入
    
  - 压缩`javascript`和`css`
    
  - 删除不必要的脚本
    
  - 减少`DOM`访问

- 图片方面

  - 优化图片：根据实际颜色需要选择色深、压缩

  - 优化`cssSprites`

  - 不要在`HTML`中拉伸图片

### 语义化的理解

- 用正确的标签做正确的事情
- `HTML`语义化就是让页面的内容结构化，便于浏览器、搜索引擎解析
- 在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的
- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于`SEO`
- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解

### 介绍一下你对浏览器内核的理解

- 主要分为两部分：渲染引擎(`Layout Engineer`或`Rendering Engineer`)和`JS`引擎
- 渲染引擎：负责获取网页的内容(`HTML`、`XML`、图像等)、整理讯息(例如加入`CSS`)等，以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器，电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
- `JS`引擎：解析和执行`javascript`来实现网页的动态效果
- 最开始渲染引擎和`JS`引擎并没有区分很明确，后来`JS`引擎越来越独立，内核就倾向于只指渲染引擎

### 从浏览器地址栏输入URL到显示页面的步骤

1. 浏览器将请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求（DNS域名解析）（三次握手）
2. 服务器将请求交给后台处理完成后返回数据，浏览器接收文件（HTML、CSS等文件）
3. 浏览器解析接收到的文件，渲染并显示到显示屏上（浏览器渲染机制）
4. TCP四次握手关闭连接

### 常见浏览器内核

- IE(9以前)=Trident+Jscript
- IE(9以后)=Trident+Chakra
- 360=Trident+Blink
- 搜狗=Trident+WebKit
- Firefox=Gecko+JagerMonkey
- Safari=webkit=webcore+jscore
- Chrome=Blink+v8
- Opera=Blink+v8 

# HTML

## 基础

### 1. Doctype有什么作用？严格模式与混杂模式如何区分？它们有何意义？

- 声明文件类型定义(`DTD`)，`<!DOCTYPE>`位于文档中最前面，处于`<html>`标签之前，作用是为了告知浏览器应该用那种文档类型规范来解析文档
- `DOCTYPE`不存在或者格式不正确会导致文档以混杂模式呈现
- 严格模式的排版和`JS`运作模式是以该浏览器支持的最高标准运行；混杂模式页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作

### 2. `meta`标签能用来做什么

- 提供给机器解读的一些元数据：页面搜索引擎优化、定义页面使用语言等等。有两个属性：

1. `http-equiv + content`
   - `charset`：编码格式
   - `expires`：过期时间
   - `refresh`：特定时间内自动刷新跳转
   - `pragma`：禁止浏览器从本地计算机缓存中访问页面内容`no-cache`
   - `windows-target`：设定页面在窗口中以独立页面显示，防止被当成`frame`页调用
   - `set-cookie`：自定义`cookie`
   - `content-type`：字符集

2. `name + content`
   - `keywords`：关键字
   - `description`：主要内容
   - `robots`：`none`不被检索
   - `author、generator`：使用的制作软件
   - `copyright`
   - `viewport`：缩放比例

### 3. `src`和`href`的区别

- `href`指向网络资源位置，建立当前文档和资源的连接，一般用于超链接
- `src`将资源嵌入当前文档中，在请求`src`资源时会将其指向的资源下载并应用到当前文档内，例如`JS`脚本，`img`图片和`iframe`等元素。当浏览器解析该元素时，会暂停其他资源的下载和处理，直到将该元素加载、编译、执行完毕，图片和框架等元素也是如此。

### 4. `<img>`的`title`和`alt`有什么区别

- `title`属性，通常当鼠标滑动到元素上的时候显示
- `alt`是`<img>`的固有属性，是图片内容的等价描述，用于图片无法加载时显示，可提高图片的可访问性，出了纯装饰性图片外都必须设置有意义的值，搜索引擎会重点分析

### `iframe`有什么缺点

- `iframe`会阻塞主页面的onload事件
- 搜索引擎的检索程序无法解读这种页面，不利于SEO
- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
- 如果需要使用`iframe`，最好通过`JS`动态给`iframe`添加`src`属性

### `xhtml`和`html`有什么区别

- 功能上：`xhtml`可兼容各大浏览器，手机以及`pda`(手持终端)，并且浏览器能快速正确的编译网页
- 书写习惯：`xhtml`元素必须被正确嵌套、闭合、区分大小写，文档必须拥有根元素

### `HTML`的全局属性(`global attribute`)有哪些

- `class`：为元素设置类标识
- `data-*`：为元素增加自定义属性
- `draggable`：设置元素是否可拖拽
- `id`：元素`id`，文档内唯一
- `lang`：元素内容的语言
- `style`：行内`css`样式
- `title`：元素相关的建议信息

## HTML5

### `HTML5`为什么只需要写`<!DOCTYPE HTML>`

- `HTML5`不基于`SGML`，因此不需要对`DTD`进行引用，但是需要`doctype`来规范浏览器的行为

### `HTML5`有哪些新特性、移除了那些元素

- `HTML5`现在已经不是`SGML`的子集，主要是关于图像、位置、存储、多任务等功能的增加：
  - 绘画`canvas`
  - 用于视频、音频的`video`和`audio`元素
  - 本地离线存储`localStorage`长期存储数据，浏览器关闭后数据不丢失
  - `sessionStorage`的数据在浏览器关闭后自动删除
  - 语义化更好的内容元素，比如`article`、`footer`、`header`、`nav`、`section`
  - 表单控件：`calendar`、`date`、`time`、`email`、`url`、`search`
  - 新的技术：`webworker`、`websocket`、`geolocation`
- 移除的元素
  - 纯表现的元素：`basefont`、`big`、`center`、`font`、`s`、`strike`、`tt`、`u`
  - 对可用性产生负面影响的元素：`frame`、`frameset`、`noframes`
- 支持`HTML5`新标签
  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生新标签，可以利用这一特性让这些浏览器支持`HTML5`新标签
  - 浏览器支持新标签后，还需要添加标签默认样式

### `canvas`和`svg`有什么区别

- `svg`绘制出来的每一个图形元素都是独立的`DOM`结点，能够方便的绑定事件或用于修改。`canvas`输出的是一整幅画布
- `svg`输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。`canvas`输出标量画布，就像一张图片一样，放大会失真和锯齿
- `highcharts`底层使用svg；`echarts`底层使用canvas



# CSS

## 基础

### 页面导入样式时，使用link和@import有什么区别

- link属于XHTML标签，除了加载CSS外，还能用于定义RSS、定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS
- 页面被加载时，link会同时被加载；而@import应用的CSS会等到页面被加载完再加载
- @link是XHTML标签无兼容问题；而import是CSS2.1提出的，只在IE5以上才能被识别

### `position`的属性及作用

- `static`：默认值，没有定位，元素出现在正常的文档流中，不会受left、top、right、bottom及z-index的影响
- `relative`：相对定位，相对其正常位置进行定位，可通过left、top、right、bottom的值来设置位置；并且原本所占的空间不变，即不会影响其他元素布局；经常被用来做绝对元素的容器块
- `absolute`：绝对定位，相对于最近的除`static`以外的第一个已定位的父元素，若没有则相对于html定位。脱离了文档流，不占据文档空间；若设置`absolute`，但没有设置top、left等值，其位置不变；若设置`absolute`，会影响未定义宽度的块级元素，使其变为包裹元素内容的宽度
- `fixed`：固定定位，相对于浏览器窗口定位，脱离文档流，不会随页面的滚动而变化
- `sticky`：粘性定位，该定位基于用户滚动的位置。它的行为就像`position:relative`；而当页面滚动超出目标区域时，它的表现就像`position:fixed;`，它会固定在目标位置。
- `inherit`：规定应该从父元素继承`position`属性的值

### `display`的属性及作用

- `none`：该元素不会显示，并且该元素的空间也不存在，可理解为已删除
- `inline`：内联元素，与其他元素在一行；不可设置宽高；margin-top与margin-bottom无效，但margin-left和margin-right有效；padding-left和padding-right同样有效，但是padding-top和padding-bottom不会影响元素高度，会影响背景高度
- `inline-block`：行内块元素，既是内联元素，又可设置宽高以及行高及顶和底边距
- `block`：此元素显示为块级元素，此元素前后会带有换行符
- `inherit`：规定该元素从父元素集成`display`的值

### CSS的盒子模型

- 理解：所有HTML元素可以看作盒子。CSS盒模型本质上是一个盒子，封装周围的HTML元素
- 内容：边距（margin）、边框（border）、填充（padding）、内容（content）
- 包括：IE盒子模型，W3C盒子模型
- 区别：IE的content把border和padding也算了进去

### BFC

- 作用：它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用
- 什么情况下会触发：
  - 根元素
  - 设置了float属性，并且不为none
  - position属性设置为absolute或fixed
  - display为inline-block、table-cell、table-caption、flex、inline-flex
  - overflow属性不为visible
- 作用：
  - 可以包含浮动元素
  - 不被浮动元素覆盖
  - 阻止父子元素的margin 折叠

### 元素隐藏的方法和区别

- `display:none`：元素不可见、不占据空间、资源会加载、`DOM`可以访问
- `visibility:hidden`：元素不可见、不能点击、但占据空间、资源会加载、可以使用
- `opacity:0`：元素不可见、可以点击、占据空间、可以使用（若想不占据空间：`position:absolute`；不能点击不占据空间：`position:absolute;z-index:-1;`不能点击占据空间：`position:relative;z-index:-1;`）

### `display:none`和`visibility:hidden`的却别

- `display:none`元素不占据空间；`visibility:hidden`元素保留
- `display:none`会影响`opacity`过渡效果
- `display:none`会产生重绘回流；`visibility:hidden`只重绘
- `display:none`节点和子孙节点都不可见，`visibility:hidden`的子孙节点可以设置`visibility:visible`显示
- `visibility:hidden`不会影响计数器计数（`ol`标签）

### `rem`、`em`和`px`的区别

- `px`：绝对长度单位
- `em`：相对长度单位，继承父级元素的字体大小，所有字体都是相对于父元素大小的
- `rem`：相对长度单位，相对于根元素（HTML）

### 浮动和清除浮动

- 浮动：当元素设置为`float`后，该元素会脱离文档并向左或向右浮动，直到碰到父元素或另一个浮动元素，浮动元素会造成父元素高度塌陷，所以设置完浮动之后需要进行清除浮动

- 清除浮动：`BFC`、带有`clear:both`的空元素、伪元素`::after`+`clear:both`

  - `BFC`：给父容器加上`overflow:hidden`形成`BFC`；需要计算超出的大小来隐藏，所以父容器会撑开放入子元素，同时计算浮动的子元素。**一旦子元素大小超过父容器大小就会显示异常**
  - 带有`clear:both`的空元素：在浮动元素后面添加一个带有`clear:both`属性的不浮动的空元素；**但是需要添加额外的`html`标签，这违背了语义化的原则
  - 使用伪元素`::after`+`clear:both`：它在父容器尾部自动创建一个子元素，原理和空元素一样，可以把它设置为`height:0`不显示，`clear:both;display:block`，保证空白字符不浮动区块。（**但是`after`不支持`IE6`，只需要添加上`zoom:1`，这是激活父元素的`haslayout`属性，让父元素拥有自己的布局）

  ```css
  .clearifx::after{
      content:'';
      height:0;
      clear:both;
      display:block;
  }
  .clear{
  	zoom:1;
  }
  ```

### 行内元素有哪些？块内元素有哪些？空元素有哪些？行内元素和块级元素有什么区别？

- 行内元素有：`a b span img input select strong`
- 块内元素有：`div ul ol li dl dt dd h1 h2 h3 h4 p...`
- 空元素有：`br hr img input link meta`
- 行内元素不可以设置宽高，不独占一行
- 块级元素可以设置宽高，独占一行

### 伪元素和伪类

**伪类可以理解为是一种状态，而伪元素则代表一些实实在在存在的元素，但是它们都是抽象刻画的，游离于标准文档之外。**

伪类存在的意义是为了通过选择器，格式化dom树以外的信息（`:visited,:link`），以及不能被常规CSS选择器获取到的信息

（比如说获取第一个子元素，常规css选择器不行,可以用：`first-child`）。

伪类常用的有`first-child、last-child、nth-child、first-of-type` (父元素第一个特定的子元素)、`last-of-type、`

`nth-of-type、lang、focus 、lvha`（a标签四个）

伪元素可以创建一些文档语言无法创建的虚拟元素，比如文档语言没有一种机制可以描述元素内容第一个字母或者第一行，但是伪

元素可以`::first-letter,::first-line` 。同时伪元素还可以创建文档中不存在的内容比如说`::after,::before` 

伪元素主要有：

`::after,::before,::first-letter,::first-line,::selection`

### CSS选择器的权重

0. !important 权重无限大

1. 代表内联样式，如: style=””，权值为1000。

2. 代表ID选择器，如：#content，权值为0100。

3. 代表类，伪类和属性选择器，如.content，权值为0010。

4. 代表类型选择器和伪元素选择器，如div p，权值为0001。

5. 通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。

6. 继承的样式没有权值。

### 外边距重叠

多个相邻(兄弟或父子) 普通流的块级元素在垂直方向的margin会重叠

- 两个相邻的外边距都为正数，折叠结果是较大的值
- 两个相邻的外边距为负数，折叠结果是绝对值较大的值
- 两个相邻外边距为一正一负，折叠结果是他们的和

### img和background-image的区别

- 解析机制：`img`属于`html`标签，`background-image`属于`css`，`img`先解析
- `SEO`：`img`标签有一个`alt`属性可以指定图像的替代文本，有利于`SEO`，并且图片加载失败时有利于阅读
- 语义化角度：`img`语义更加明确

### rgba()和opacity的区别

- `opacity`：作用于元素及元素中的所有内容，有继承性
- `rgba()`：只作用于元素的颜色和背景色
- 当`opacity`属性的值应用于某个元素时，把这个元素和它内容当做一个整体来看待，即使这个值没有被子元素继承。因此一个元素和它包含的元素都会有与元素背景相同的透明度，哪怕父子元素有不同的`opacity`值

### outline和border的区别

- `outline`轮廓是绘制于元素周围的一条线，位于边框边缘的外围，起到突出元素的作用
- `outline`的效果将随元素的`focus`而自动出现，相应的有由`blur`自动消失，这些是浏览器的默认行为
- `outline`不占据空间，不会像`border`那样影响元素的尺寸或者位置

### 脱离文档流的方式

```css
position:absolute
position:fixed
float
```

### z-index

z-index属性制定一个元素的堆叠顺序

拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素前面

**注意：z-index进行定位元素（`postion:absolute, position:relative, position:fixed`）**

属性值：

- `auto`：默认，堆叠顺序与父元素相等
- `number`：设置元素的堆叠顺序
- `inherit`：规定应该从父元素继承z-index的值

### position和float的区别

相同点：position设置absolute或fixed后和设置了float后都会脱离文档流

不同点：position相应的块级元素会覆盖下面的内容，而float只会覆盖块级元素，里面的文字会脱离

**文档流**： 文档中可显示对象在排列时所占用的位置

## CSS3

### CSS3有哪些新特性

- 新增选择器：E：nth-child(n) E:nth-last-child(n)
- Transition、Transform和Animation
- 边框：box-shadow,border-radius
- 背景：background-clip,background-size
- 文字：text-shadow,text-overflow
- 字体：@font-face

```css
@font-face{
	font-family:myFirstFont;
	src:url(sansation_light,woff);
}
```

- 线性渐变

### CSS3的`box-sizing`值有哪些

box-sizing有三种属性，一种是content-box，一种是border-box,还有一个是从父元素继承的inherit。
现在还有一个padding-box。

- content-box 一 宽高应用到内容框
- border-box — 宽高包括了内边距和边框
- padding-box — 高宽包括了内边距

### CSS动画如何实现

创建动画序列，需要animation属性或其子属性，属性允许配置动画时间、时长和动画细节。动画的实际表现由`@keyframes`实现

transtion也可以实现动画，但强调过渡，是元素的一个或多个属性变化时产生的过渡效果，同一个元素通过两个不同的途径获取样

式，而第二个途径当某种改变发生时（如：hover)才能获取样式，这样就会产生过渡动画。

### transition、animation的区别

`animation`和`transition`大部分属性相同，都是随时间改变元素的属性值，区别是`transition`需要触发一个事件才能改变属性；`animation`不需要触发任何事件随时间改变属性。`transition为2`帧，从`from……to` ，`animation`可以一帧一帧的。

```css
transition：
div{
    transition-property:width;
    transition-duration:1s;
    transition-timing-function:linear;
    transition-delay:25;
    /*简写形式*/
    transition:width 1s linear 25;
}
transform:
div{
    transform:rotate(7deg);
    -ms-transform:rotate(7deg);/*IE9*/
    -moz-transform:rotate(7deg);/*FireFox*/
    -webkit-transform:rotate(7deg);/*Safari和Chrome*/
    -o-transform:rotate(7deg);/*Opwea*/
}
animation:
@keyframes myAnimation{
    0%{background:red;width:100px;}
    25%{background:orange;width:200px;}
    50%{background:yellow;width:100px;}
    75%{background:green;width:200px;}
    100%{background:blue:width:100px;}
}
#box{
    animation:myAnimation 5s;
    width:100px;
    height:100px;
    background:red;
}
```

## 布局

### 	水平居中的实现方案

- 块级元素撑满父元素：如果宽度一定，在子元素添加`margin:auto`就可以平分剩余空间
- 行内块居中：把父元素设置为`text-align:center`，之后子元素设置`display:inline-block`
- 绝对定位：`position:absolute;`，**但是不会撑满父级元素**
- 相对定位：`position:relative;`，会撑满父级元素
- `flex`：父元素`display:flex; justify-content:center;`

### 垂直居中的实现方案

- 元素无高度

  利用内边距，让块级文字包裹在padding中，实现垂直居中

- 父元素高度确定的单行文本

  使用行高的特性：父元素设置`height:line-height`即可

- 父元素高度确定的多行文本

  - 父元素设置`display:table`，子元素设置`display:table-cell; vertical-align:middle`
  - 子元素设置`display:inline-block`，父元素设置`line-height=height`

- 父元素高度未知

  - 绝对定位，设置`top:50%`

- `flex·`

  父元素设置：`display:flex; align-items:center;`

### 垂直水平居中的实现方案

- 居中元素宽高已知

  - 利用绝对定位和margin

    ```css
    parent{
    	position: relative;
    }
    child{
        postion: absolute;
        top: 50%;
        left: 50%;
        margin-top:(-h/2)px;
        margin-left:(-h/2)px;
    }
    ```

  - `absolute`+`margin:auto`

    ```css
    child{
    	width:50px;
        height:50px;
        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
        margin:auto;
    }
    ```

  - 用`calu`计算

    ```css
    child{
    	position:absolute;
        top:calu(50%-50px);
        left:calu(50%-50px);
    }
    ```

- 垂直元素的宽高未知

  - `transform`的`translate`方法

    ```css
    child{
    	position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    ```

  - `flex`布局

    ```css
    child{
    	display:flex;
        align-items: center;
        justify-content: center;
    }
    ```

### Flex布局

`flex`是弹性布局，用来为盒装模型提供最大的灵活性。布局的传统解决方案基于盒装模型，依赖`display`、`position`、和`float`属性，任何一个容器都可以指定为`flex`布局

**注意**：**设置为`flex`布局后，子元素的`float`、`clear`、`vertical-align`属性会失效**

`flex`属性分为容器属性和元素属性：

- 容器属性包括：

  - `flex-direaction`：决定主轴方向

    ```css
    .box{
        flex-direaction: row|row-reverse|column|column-reverse;
    }
    ```

  - `flex-wrap`：决定了如何换行

    ```css
    .box{
    	flex-wrap: nowrap|wrap|wrap-reverse;
    }
    ```

  - `flex-flow`：上面两个的简写

    ```css
    .box{
    	flex-flow: <flex-direaction>||<flex-wrap>;		
    }
    ```

  - `justify-content`：水平轴对齐方式

    ```css
    .box{
    	justify-content: flex-start|flex-end|center|space-between|space-around;
    }
    ```

  - `align-items`：垂直轴对齐方式

    ```css
    .box{
    	align-items: flex-start|flex-end|center|space-between|space-around;
    }
    ```

- 元素属性`align-content`

  - `order`：定义项目的排序顺序，越小越靠前
  - `flex-grow`：放大比例，默认是0，即使存在空间也不会放大，1是说等分剩余空间
  - `flex-shrink`：缩小比例，当空间不够的情况下，会等比缩小；为0不缩小，为1等比缩小
  - `flex-basis`：定义分配多余空间时，项目占据的控件
  - `flex`上面三个属性的缩写，默认是0 1 auto。后两个属性可选
  - `align-self`：允许单个与其他不一样的方式，可以覆盖`align-item`的属性，默认是`auto`表示继承

### Grid布局

容器属性

- display:grid 指定一个容器采用网格布局
- grid-template-columns 定义每一列的列宽 可以用百分比
- grid-template-rows 定义每一行的行高 可以用百分比

```css
/*九宫格布局*/
.container{
    display:gird;
    grid-template-columns:33.33% 33.33% 33.33%;
    grid-template-rows:33.33% 33.33% 33.33%;
}
```

- grid-row-gap 行间距
- grid-column-gap 列间距
- grid-gap 上面两个的简写

### 静态布局

**特点**：不管浏览器尺寸是多少，网页布局始终按照最初写代码时的布局来显示

一般都使用`min-width`定宽，小于这个宽度就会出现滚动条，大于就内容居中加背景

**设计方法**：

- PC端居中布局所有样式绝对宽高，设计一个`layout`，在屏幕宽高有调整时，使用横向和竖向滚动条来查阅被遮掩的部分
- 移动设备另外建立，单独设计一个布局，使用不同的域名如`wap`或`m`

### 流式布局

**特点**：屏幕分辨率变化时，页面里元素的大小会变化但布局不变。**导致如果屏幕太大或太小都会导致元素无法正常显示**

**设计方法**：使用`%`百分比定义宽度，高度大都是用`px`来固定住，可以根据可视区域`viewport`和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合`max-width/min-width`等属性控制尺寸流动以免过大或者过小影响阅读

这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式，但缺点明显：**如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示**。因为宽度使用`%`百分比定义，但是高度和文字大小等大都是用`px`来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样，显示非常不协调。

### 自适应布局

**特点**：屏幕分辨率变化时，页面里元素位置会变化而大小不会变化

**设计方法**：使用`@media`媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局

### 响应式布局

**特点**：每个屏幕分辨率下都会有一个布局样式，即元素大小位置都会变。

**设计方法**：**媒体查询+流式布局**，通常使用`@media`媒体查询和网格系统（`Grid System`）配合相对布局单位进行布局。实际上就是综合响应式、流动等上述技术通过`CSS`给单一网页不同设备返回不同样式的技术统称

**优点**：适应PC端和移动端，如果足够耐心，效果完美

**缺点**：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本

### 弹性布局

**特点**：包裹文字的各元素的尺寸采用`em/rem`做单位，而页面的主要划分区域的尺寸仍使用百分数或`px`做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用`em/rem`做单位，可以使包裹文字的元素随着文字的缩放而缩放。

## CSS模块化(未完成)





# `Javascript`

## 基础

### 写`JavaScript`的基本规范

- 不要在同一行声明多个变量
- 使用`===/!==`来比较`true/false`或者数值
- 使用对象字面量替代`new Array`这种形式
- 不要使用全局函数
- `switch`语句必须带有`default`分支
- `if`语句必须使用大括号
- `for-in`循环中的变量应该使用`var`关键字限定作用域，从而避免作用域污染

### `javascript` 代码中的`"use strict"`是什么意思 ? 使用它区别是什么？

`use strict`是一种`ECMAscript 5`添加的（严格）运行模式，这种模式使得 `Javascript`在更严格的条件下运行，使`JS `编码更加规范化的模式，消除`Javascript`语法的一些不合理、不严谨之处，减少一些怪异行为

### 严格模式的限制

- 变量必须先声明再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用`with`语句
- 禁止`this`指向全局对象

### `JavaScript`的基本数据类型

`undefined`、`null`、`boolean`、`number`、`string`、`symbol`（表示独一无二的值，常是用来定义对象的唯一属性名）

### `JavaScript`有哪些内置对象

- `Object`是`JavaScript`中所有对象的父对象
- 数据封装类对象：`Object`、`Array`、`Boolean`、`Number`、`String`
- 其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`

### 基本数据类型与对象类型的区别

- 基本类型存储的是值，对象类型存储的是地址
- 当创建了一个对象类型的时候，计算机会在内存中开辟一个空间来存放值，我们会引用这个地址(指针)来使用这个对象

### `typeof`和`instanceof`

- `typeof`对于基本数据类型来说，除`null`会显示成`Object`，其余都可以显示正确的类型；`typeof`对于对象来说，除了函数都会显示`Object`；所以`typeof`并不能准确判断变量到底是什么类型
- 如果想判断一个对象的正确类型可以使用`instanceof`，因为内部机制是通过原型链来判断的

### 如何判断一个对象类型是数组

- 用`instanceof`判断：``` xxx instanceof Array```
- 用`class`属性判断：`Object.prototype.toString.call(obj) === '[Object Array]'`
- 用`isArray`判断

### `null`和`undefined`的区别

- `undefined`：表示不存在这个值；是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有被定义，当尝试读取时会返回`undefined`。例如变量被声明了但是没有赋值，就等于`undefined`
- `null`：表示一个对象被定义了，值为"空值"；是一个空对象（没有任何属性和方法）；例如作为函数的参数，表示该函数的参数不是对象
- 在验证`null`时，一定要使用 `===`，因为`==`无法区分`null`和`undefined`

### `eval`函数是做什么的

- 把对应的字符串解析成`JS`代码并执行

- 应该避免使用`eval`，不安全，非常耗性能（2次，一次解析成`js`语句，一次执行）
- 由`js`字符串转换为`JSON`对象的时候可以用`eval`：`var obj = eval('(' + str + ')')`

### call函数

- 用法：`call(this, ...args)`
- 本质：往要绑定的`context`对象下添加函数，然后执行，最后将属性删除。 当context值为null，或者undefined时，非严格模式下，它将替换为window或者global全局变量
- 源码：

```js
Function.prorotype.call = function(context) {
    var context = context || window;
    context.fn = this;
    
    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++){
        args.push('arguments[' + i + ']');
    }
    
    var result = eval('context.fn(' + args + ')');
    
    delete context.fn;
    return result;
}
```

### apply函数

- 用法：`apply(this, [arguments])`
- 本质：往要绑定的`context`对象下添加函数，然后执行，最后将属性删除。 当context值为null，或者undefined时，非严格模式下，它将替换为window或者global全局变量
- 源码：

```js
Function.prototype.apply = function(context){
    var context = Object(context) || window;
    context.fn = this;
    
    var result;
    if(!arr){
        result = context.fn();
    }
    else{
        var args = [];
        for(var i = 0; len = arr.length; i < len; i++){
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')');
    }
    delete context.fn;
    return result;
}
```

### bind

- 用法：` var fn = bind(this, ...arguments);fn(...newarguments); `

- 原理：`bind`不会立即执行，而是返回一个函数，一般情况下，该函数执行时的`this`指向绑定的对象。而麻烦的是`JS`中函数还可以通过`new`来实例化，而实例化后的`this`指向新创建的对象。所以该函数的内部进行了额外的处理，看它是否是通过`new`创建的实例，如果是通过`new`创建的实例，`this`对象指向新创建的`new`对象实例

- 源码：

```js
if(!Function.prototype.bind){
    Function.prototype.bind = function(oThis){
        if(typeof this !== "function"){
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }
        
        var args = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function(){},
            fBound = function(){
                return fToBind.apply(this instanceof fNOP
                                    ? this
                                    : oThis || this,
                                    aArgs.concat(Array.prototype.slice.call(arguments)));
            };
        
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        
        return fBound;
    };
}
```

### 为什么call函数比apply函数高效

`Function.prototype.apply (thisArg, argArray)`

1、 如果IsCallable（Function）为false，即Function不可以被调用，则抛出一个TypeError异常。
2、如果argArray为null或未定义，则返回调用function的[[Call]]内部方法的结果，提供thisArg和一个空数组作为参数。
3、如果 Type（argArray）不是Object，则抛出TypeError异常。
4、获取argArray的长度。调用argArray的[[Get]]内部方法，找到属性length。 赋值给len。
5、定义 n 为ToUint32（len）。ToUint32（len）方法：将其参数len转换为范围为0到2^32-1的2^32个整数值中的一个。
6、初始化 argList 为一个空列表。
7、初始化 index 为 0。
8、循环迭代取出argArray。重复循环 while（index < n）
      a、将下标转换成String类型。初始化 indexName 为 ToString(index).
      b、定义 nextArg 为 使用 indexName 作为参数调用argArray的[[Get]]内部方法的结果。
      c、将 nextArg 添加到 argList 中，作为最后一个元素。
      d、设置 index ＝ index＋1
9、返回调用func的[[Call]]内部方法的结果，提供thisArg作为该值，argList作为参数列表。

`Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )`

1、如果 IsCallable（Function）为false，即Function不可以被调用，则抛出一个TypeError异常。
2、定义argList 为一个空列表。
3、如果使用超过一个参数调用此方法，则以从arg1开始的从左到右的顺序将每个参数附加为argList的最后一个元素
4、返回调用func的[[Call]]内部方法的结果，提供thisArg作为该值，argList作为参数列表

**结论**: 比较`apply`与`call`调用过程的不同，我们可以得出apply比call慢的原因主要是`apply`方法中，对`argArray`的参数有多次判断，执行步骤比call多。 

## 类型转换

**在JS中类型转换只有三种情况，分别是：**

- 转换为布尔型
- 转换为数字
- 转换为字符串

### 转换为Boolean

在条件判断时，除了`undefined`、`null`、`false`、`NaN`、`''`、`0`、`-0`，其他所有值都转为`true`，包括所有对象

### 对象转基本数据类型

**对象在转换类型的时候，会调用内置的``[[ToPrimitive]]``函数，对于该函数来说，算法逻辑一般如下：**

- 如果已经是基本数据类型，就不需要转换了
- 如果需要转字符串就调用`x.toString()`
- 如果需要转为数值就调用`x.valueOf()`
- 如果都没有返回基本数据类型，就会报错

**可以重写`Symbol.toPrimitive`，该方法在转基本数据类型时调用优先级最高**

```javascript
let a = {
    valueOf(){
        return 0;
    },
    toString(){
        return '1';
    },
    [Symbol.toPrimitive](){
        return 2;
    }
}
1 + a   // => 3
```

### 四则运算符

**加法运算符**：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果其中一方不是字符串或数字，那么会将它转换为数字或字符串

```javascript
1 + '1' => '11'  //触发特点一，将数字1转换为字符串，得到结果'11'             
true + true => 2  //触发特点二，将 true 转换为数字1
4 + [1,2,3] => '41,2,3'  //触发特点二，将数组转换为字符串'1,2,3'
```

- 表达式`'a' + + 'b' => 'aNaN'`因为`+ 'b'`等于`NaN`，所以结果为`'aNaN'`

**除了加法运算符：只要其中一方是数字，那么另外一方也会转换为数字**

 ``` javascript
4 * '3' => 12
4 * [] => 0
4 * [1,2] => NaN
 ```

### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
2. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
valueOf() {
return 0
},
toString() {
return '1'
}
}
a > -1 // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

### ==和===

- Boolean，number，string三类比较的时候把值转换成数字，在看转换结果是否相等。证明：
  （'1'==true) 是真 （'abc'==true）是假。
- undefined 参与比较，换成了NaN,所以其他三个类型跟它比较都是false，跟null类型比较的时候
  是true。（NaN==NaN)是假
- null参与比较，被当成对象，因为null没有valueof和toString，除了undefined谁跟他比较都是
  false。
- 值类型与对象比较：先调用对象valueof 如果仍返回对象，调用tostring，如果还是没有就不等。

**注意**：

```js
[]==![]
// false => 首先先执行的是![]，它会得到false。然后[]==false，返回true。

[]==[],{}=={}
// flase false
// 类型一致，它们是引用类型，地址是不一样的，所以为false!
```

对于`===`来说，就是判断两者类型和值是否相同。

## 面向对象

js有两种属性值：数据属性 访问器属性

### 数据属性

**作用**：包含一个数据值的位置

**特性**：

- Configurable 表示能否通过delete删除属性从而重新定义属性，默认为true
- Enumerable 表示能否通过for-in循环返回属性，默认为true
- Writable 表示能否修改属性的值，默认为true
- Value 包含这个属性的数据值 默认为undefined

**修改属性默认值**

使用`Object.defineProperty(obj,attr,{})`

```js
var person={}
Object.defineProperty(person,'name',{
    wirtable:false,
    value:'xxxx',
    configurable:false; //一旦被设置为false，不可以更改
})
person.name='xx'
console.log(person.name); //xxxx ，严格模式下会报错
delete person.name //无效 严格模式下会报错
```

### 访问器属性

**特性**：

- Configuable 表示能否通过delete删除属性从而重新定义属性，默认是true
- enumerable 表示能否通过for-in 循环返回属性，默认是true
- get 读取属性时调用函数，默认undefined
- set 写入属性时调用函数，默认undefined

**定义访问器属性**：

使用`Object.defineProperty()`，定义多个属性使用`Object.defineProperties()`

```js
var person={
	_age:20, //下划线写法表示只能通过对象方法访问的属性
	state:'young'
}
Object.defineProperty(person,'age',{
	get:function(){
		return this._age;
	},
    set:function(newVal){
    	if(newVal>50){
    		this._age=newVal;
    		this.stae='old';
    	}else{
    		this._age=newVal;
    	}
    }
})
```

### 读取属性的特性

使用`Object.getOwnPropertyDescriptor()`

```js
var person={}
Object.defineProperties(person,{
    _age:{
    	values:20;
    },
    state:{
    	value:'young';
    },
    age:{
        get:function(){
        	return this._age;
        },
        set:function(newVal){
            if(newVal>50){
            	this._age=newVal;
            	this.stae='old';
            }else{
            	this._age=newVal;
            }
    	}
    }
})
var descriptor=Object.getOwnPropertyDescriptor(person,'_age');
descriptor.value//20
descriptor.configurable//false
var descriptor=Object.getOwnPropertyDescriptor(person,'age');
descriptor.value//undefined
descriptor.configurable//false
typeof descriptor //function
```

## 深拷贝和浅拷贝

**深拷贝**： 是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存 

**浅拷贝**： 只是增加了一个指针指向已存在的内存地址 

假设B复制了A，修改A的时候，看B是否发生变化：

如果B跟着**也变了**，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）

如果B**没有改变**，说明是深拷贝，自食其力！（修改堆内存中的不同的值）

## DOM

### DOM如何创建元素

创建：

```js
createHTML('div');
```

添加：

```js
appendChild(element)
insertBefore(insertdom.chosendom)
```

### DOM获取元素的方式

#### 根据元素类型获取

- document.getElementById();//id名，在实际开发中较少使用，选择器中多用class id一般只用在顶级层存在 不能太过依赖id
- document.getElementsByTagName();//标签名
- document.getElementsByClassName();//类名
- document.getElementsByName();//name属性值，一般不用
- document.querySelector();//css选择符模式，返回与该模式匹配的第一个元素，结果为一个元素；如果没找到匹配的元素，则返回null
- document.querySelectorAll()//css选择符模式，返回与该模式匹配的所有元素，结果为一个类数组

#### 根据关系树来获取

- parentNode//获取所选节点的父节点，最顶层的节点为#document
- childNodes //获取所选节点的子节点们
- firstChild //获取所选节点的第一个子节点
- lastChild //获取所选节点的最后一个子节点
- nextSibling //获取所选节点的后一个兄弟节点 列表中最后一个节点的nextSibling属性值为null
- previousSibling //获取所选节点的前一兄弟节点 列表中第一个节点的previousSibling属性值为null

#### 根据元素节点树来选择

- parentElement //返回当前元素的父元素节点（IE9以下不兼容）
- children // 返回当前元素的元素子节点
- firstElementChild //返回的是第一个元素子节点（IE9以下不兼容）
- lastElementChild //返回的是最后一个元素子节点（IE9以下不兼容）
- nextElementSibling //返回的是后一个兄弟元素节点（IE9以下不兼容）
- previousElementSibling //返回的是前一个兄弟元素节点（IE9以下不兼容）

### 节点属性中children和childNodes有什么区别？

- childNodes返回的是节点的子节点集合（NodeLists),包括元素节点、文本节点还有属性节点。
- children返回的只是节点的元素节点集合（HTMLCollection)

### HTMLCollection和NodeList的比较

**共同点**：

- 都是类数组对象，都有length属性

- 都有共同的方法：item,可以通过item(index)获取返回结果的元素

- 都是实时变动的，document上面的更改会反映到相关的对象上

  **注**：querySeletorAll返回的NodeList是个浅拷贝的类数组对象，在节点数目上是非实时的，不过对节点属性进行修改，还是实时反映的。

**区别**：

- NodeList可以包含任何节点类型，HTMLCollection只包含元素节点。elementNode就是HTML中的标签。
- HTMLCollection比NodeList多一个方法：nameitem(),除了可以用id，还可以用name来获取节点信息。

### 获取DOM节点get系列和query系列哪种性能好？

**结论：**get系列的性能都比query系列好，get系列里面各有差异

**原因：**`getElementsByTagName`创建的过程不需要做任何操作，只需要返回一个指针即可。而`querySelectorAll`会循环遍历所有的的结果，然后创建一个新的`NodeList`。

## this

### 四种绑定规则

- 默认绑定

  - 全局环境，默认绑定到`window`
  - 函数独立调用的时候，`this`默认绑定到`window`
  - 被嵌套的函数独立调用时，`this`默认绑定到`window`
  - 立即执行的函数`this`是`window`
  - 闭包的`this`默认绑定到`window`

- 隐式绑定

  - 被直接对象所包含的函数调用时，也称为方法调用，`this`隐式绑定到该直接对象

- 显示绑定

  - 通过call()、apply()、bind()方法把对象绑定到`this`上，叫做显式绑定。对于被调用的函数来说，叫做间接调用；多次调用bind()，`this`永远由第一次`bind`决定。

- `new`绑定

  - 如果函数或者方法调用之前带有关键字`new`，就构成构造函数式调用，称为`new`绑定

- 箭头函数

  - 箭头函数是没有`this`的，箭头函数中的`this`只取决包裹箭头函数的第一个普通函数

  ```javascript
  function a(){
      return () => {
          return () => {
              console.log(this);
          }
      }
  }
  console.log(a()()());
  ```

  在上例中，因为包裹箭头函数的第一个普通函数是`a`，所以此时的`this`是`window`。另外箭头函数使用`bind`这类函数是无效的

### 优先级

- `new()`绑定 > `bind`这些函数（显式绑定） > `obj.foo()`（隐式绑定）> `foo()`(默认绑定)
- 箭头函数的`this`一旦被绑定，就不会再被任何方式改变

### 为什么this绑定的优先级是这样的

可参考`bind`绑定this的原理

## 作用域链、闭包、原型链

### 作用域链

- 定义：**作用域**是指代码的执行环境。代码执行时最先产生的执行环境称为全局作用域，如浏览器为window，node为global。作用域内部执行时产生的、新的作用域为局部作用域。由此逐层产生、逐层嵌套的作用域，称为作用域链
- 作用：保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，访问到window即被终止，不能向下访问

### 闭包

- 定义：闭包就是有权访问另一个函数作用域中变量的函数。创建闭包最常见的方式就是在函数内部创建另一个函数，通过另一个函数能够这个函数的局部变量，利用闭包可以突破作用域链
- 作用：读取函数内部变量，让这些变量一直保存在内存中；封装对象的私有属性和私有方法
- 优点：避免全局污染
- 缺点：闭包会常驻内存，增大内存使用量

### 原型链

- 定义：每个对象都会在其内部初始化一个属性，就是`prototype`（原型）。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去`prototype`里找这个属性，这个`prototype`又有自己的`prototype`，于是这样一直找下去，知道`Object`内建对象，就是原型链
- 特点：`instance.contructor.prototype = instance.__proto__`

- **怎么判断一个属性是对象上的属性还是其原型对象上的属性**：使用`hasOwnProperty()`返回`true`，说明是这个对象上的；如果返回`false`，但是属性`in`这个对象返回了`true`，说明是原型对象上的属性。如果都是`false`，不存在这个属性。

## 继承

### 继承的原理

每个函数都有个原型对象，这个对象用来存储通过这个函数所创建的所有实例的共有属性和方法。在读取某个对象属性的时候，从实例开始，如果实例有就返回，如果没有就找原型对象，找到了就返回。通过实例只能访问原型对象里的值，但是不能修改。这就实现了继承。

### 组合继承

```javascript
function Parent(value){
    this.val = value;
}
Parent.prototype.getValue = function(){
    console.log(this.value);
}
function Child(value){
    Parent.call(this,value)
}
Child.prototype = new Parent();

const child = new Child(1);
child.getValue();      // 1
child instanceof Parent;    // true
```

以上继承方式的核心是在**子类的构造函数中`Parent.call(this, value)`继承父类属性，然后**改变子类的原型为`new Parent()`来继承父类函数。

这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费

### 寄生组合继承

这种继承方式对组合继承进行了优化，组合继承的缺点在于继承父类函数时调用了构造函数，只要优化掉这点就行了

```javascript
function Parent(value){
    this.val = value;
}
Parent.prototype.getValue = function(){
    console.log(this.val);
}
function Child(value){
    Parent.call(this, value);
}
Child.prototype = Object.create(Parent.prototype, {
    constructor:{
        value: child,
        enumerable: fasle,
        writeable: true,
        configurable: true
    }
})
const child = new child(1);

child.getValue() // 1
child instanceof Parent // true
```

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数

### class继承

在`ES6`中，可以使用`class`去实现继承

```javascript
class Parent{
	constructor(value){
		this.val = value;
	}
	getValue(){
		console.log(this.val);
	}
}
```

## 事件

### 事件循环（EventLoop)

浏览器执行是有一个执行栈的，当遇到异步的代码时，异步代码会被挂起并在需要执行的时候加入到Task队列里面，一旦执行栈为空，EventLoop会从Task队列里拿出需要执行的代码放入执行栈中执行。执行完毕后就会弹出。

但是不同的任务源会被分到微任务（micro-task）和宏任务（macro-task）里面

宏任务：`script`，`setTimeout`，`setInterval`，`I/O`，`UI rendering`

微任务：`process.nextTick`，`Promise`，`Object.observe`，`MutatuibObserver`

***执行顺序***

1. 首先执行同步代码，属于宏任务
2. 执行完所有宏任务之后，查询有没有异步代码需要执行，然后执行微任务
3. 执行微任务之后，如果有必要会重新渲染页面
4. 然后一下轮执行宏任务中异步代码，比如说setTimeout的回调函数。

**Promise定义之后便会执行，Promise的`then`为异步里面的微任务且优先级高于`setTimeout`**

### 事件模型

- 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发
- 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发
- DOM 事件流：同时支持两种事件模型：捕获型事件和冒泡型事件
- 阻止冒泡：在W3c 中，使用`stopPropagation()` 方法；在IE下设置`cancelBubble = true`
- 阻止捕获：阻止事件的默认行为，例如click - <a> 后的跳转。在W3c 中，使用`preventDefault() `方法，在IE 下设置`window.event.returnValue = false`

### addEventListener三个参数

第一个参数是事件类型，第二个是事件发生的回调函数，第三个是个布尔值，默认是false，false是冒泡阶段执行，true是捕获阶段。

### 事件代理

事件代理（ Event Delegation ），又称之为事件委托。是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。

使用事件代理的好处:

- 可以提高性能可以大量节省内存占用，减少事件注册，比如在table 上代理所有td 的click 事件就非常棒
- 可以实现当新增子对象时无需再次对其绑定

## ES6

### let const 及 var的区别

**let**

- 作用域是块级作用域（之前只有函数作用域和全局作用域）

- 不存在变量声明提前（在`let`之前使用会报错，`is not defined`）

- 不可以重复定义（`var`可以，不会报错；`let`会报错`has already been declared`）

- 存在暂时性死区

  - **理解**：在一个块级作用域中，变量唯一存在，一旦声明了一个，就属于这个块级作用域，不受外部影响

  - **本质**：只要已经入当前作用域，所要用的变量就已经存在了，但是不可以获取，等到变量声明后才可以使用

  - **意义**：标准化代码，将所有的变量声明放在最前面

    ```javascript
    var a=1;
    if(1){
        console.log(a);
        let a=2;
    }
    //cannot access 'a' before initialization
    ```

**const**

- 一般用来声明常量，不允许修改
- 只读属性，声明同时要赋值
- 和`let`一样，都是块级作用域，存在暂时性死区，没有变量声明提前，不允许重复定义

**var**

- 作用域是函数作用域，在一个函数内部用`var`声明一个变量，则这个变量只在函数内有效
- 存在变量声明提前（但是赋值没有提前，提前访问会返回`undefined`）

**如果在函数内引用的变量是let定义的局部变量，就会形成闭包。如果函数内引用的是`var`定义的全局变量，就不会形成闭包**

### 为什么需要块级作用域

`ES5`只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景

- 内层变量可能会覆盖外层变量

  ```javascript
  var tmp = new Date();
  function f(){
      console.log(tmp);
      if(false){
          var tmp = 'hello world';
      }
  }
  
  f();   //undefined
  ```

  上面代码的原意是，`if`代码块的外部使用外层的`tmp`变量，内部使用外层的`tmp`变量，内部使用内层的`tmp`变量。但是，函数`f`执行后，输出结果为`undefined`，原因在于变量提升，导致内层的`tmp`变量覆盖了外层的`tmp`变量

- 用来计数的循环变量泄露为全局变量

  ```javascript
  var s = 'hello';
  
  for(var i = 0; i < s.length; i++){
  	console.log(s[i]);
  }
  
  cnosole.log(i); //5
  ```

  上面代码中变量`i`只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量

### Promise

`Promise`是异步问题的解决方案，简单说是个容器，里面存的是某个未来会结束的结果。

- 特点	
  - 对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
  - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就被称为`resolved`（已定型）。如果改变已经发生，再对`promise`对象添加回调函数也会立即得到这个结果。而`event`的特点是如果你错过了再去监听是得不到结果的。
- 优点
  - 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
  - `Promise`对象提供统一的接口，使得异步操作更加容易
- 缺点
  - 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消
  - 如果不设置回调函数，`Promise`内部抛出的错误，不会反映到外部
  - 当处于`pending`状态时，无法得知目前进展到哪一阶段
- 基本用法

```javascript
const promise = new Promise(function(resolve, reject){
    //some code
    if(/*异步操作能成功*/){
    	resolve(value);   
    }else{
    	reject(error);                        
    }
});
```

`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由`javascript`引擎提供，不用自己部署。

`resolve`函数的作用是将`Promise`对象的状态从"未完成"变为"成功"（即从`pending`变为`resolved`），在异步操作成功时调用，并将异步操作的结果变为参数传出去；`rejected`函数的作用是，将`Promise`对象的状态从"未完成"变成"失败"（即从`pending`变为`rejected`），在异步操作时调用，并将异步操作报出的错误作为参数传出去

- `then`方法--`Promise.prototype.then()`

  作用：为`Promise`实例添加状态改变时的回调函数（可以采用链式写法，即`then`方法后面再调用另一个`then`方法）。`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数

  ```javascript
  getJSON("/posts.json").then(function(json){
  	return json.post;
  }).then(function(post){
      // ...
  })
  ```

  上面代码中使用的`then`方法，依次指定了两个回调函数。第一个回调函数完成以后，会将***返回结果***作为参数传入第二个回调函数。若前一个回调函数返回的是一个`Promise`对象（即有异步操作）

- `catch`方法--`Promise.prototype.catch()`

  `Promise.prototype.catch`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数

  ```javascript
  p.then((val) => console.log('fulfilled:', val))
   .catch((err) => console.log('rejected:', err));
  
  //等同于
  p.then((val) => console.log('fulfilled:',val));
   .then(null, (err) => console.log('rejected:', err))
  ```

  如果异步操作跑出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数处理这个错误。另外`then`方法指定的回调函数如果运行中抛出错误，也会被`catch`方法捕获

  由于`catch`是`then`方法的别名，所以`catch`也可以链式调用

- `finally`方法--`Promise.prototype.finally()`

  `finally`方法用于指定不管`Promise`对象的最后状态如何，都会执行的操作。本质上是`then`方法的特例

  ```javascript
  promise.finally(( => {
  	// 语句                 
  }));
  
  // 等同于
  promise.then(result => {
      // 语句
      return result;
  }, error => {
      // 语句
      throw error;
  })
  ```

- `Promise.all()`

  `Promise.all()`方法用于将多个`Promise`实例，包装成一个新的`Promise`实例

  ```javascript
  const p = Promise.all([p1, p2, p3]);
  ```

  `Promise.all()`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是`Promise`实例，如果不是就会先调用`Promise.resolve`方法，将参数转换为`Promise`实例，再进一步处理。`Promise.all`方法的参数可以不是数组，但必须具有`Iterator`接口，且返回的每个成员都是`Promise`实例

  `p`的状态由`p1`、`p2`、`p3`决定，分为两种情况

  1.  有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数
  2.  只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数

- `Promise.race()`

  `Promise.race()`同样是将多个`Promise`实例包装成一个新的`Promise`实例

  ```javascript
  const p = Promise.race([p1, p2, p3])
  ```

  上面代码中，只要`p1`、`p2`、`p3`之中有一个率先改变状态，`p`的状态就跟着改变。那个率先改变的`Promise`实例的返回值，就传给`p`的回调函数。其中`Promise.race`的参数如果不是`Promise`实例就会调用`Promise.reslove`方法

### Proxy

- 概述：用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种"元编程"（`meta programming`），即对编程语言进行编程。`Proxy`可以理解成，在目标对象之前架设一层"拦截"，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

  ```javascript
  var obj = new Proxy({}, {
  	get: function(target, propKey, receiver){
          console.log(`getting ${propKey}!`);
          return Reflect.get(target, propKey, receiver);
      },
      set: function(target, propKey, receiver){
      	console.log(`setting ${propKey}!`);
          return Reflect.set(target, propKey, receiver);
  	}
  });
  
  obj.count = 1;
  // setting count!
  ++obj.count;
  // getting count!
  // setting count!
  // 2
  ```

  上面代码对一个空对象架设了一层拦截，重定义了属性的读取（`get`）和设置（`set`）行为。对设置了拦截行为的对象`obj`，去读写它的属性就会得到上面代码的结果。

- 语法：

  ```javascript
  var proxy = new Proxy(target, handler);
  ```

  `new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。

  ```javascript
  var proxy = new Proxy({}, {
  	get: function(target, propKey){
  		return 35;
  	}
  });
  
  proxy.time //35
  proxy.name //35
  proxy.title //35
  ```

  **注意**：要使得`Proxy`起作用，必须针对`Proxy`实例（上例是`Proxy`对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。由于拦截函数总是返回35，所以访问任何属性都得到35。**如果`handler`没有设置任何拦截，那就等同于直接通向原对象**

  ```javascript
  var target = {};
  var handler = {};
  var proxy = new Proxy(target, handler);
  proxy.a = 'b';
  target.a  // "b"
  ```

  上面代码中，`handler`是一个空对象，没有任何拦截效果，访问`proxy`就等同于访问`target`

- `Proxy`支持的拦截操作，一共13种
  - `get(target, propKey, receiver)`：拦截对象属性的获取，比如`proxy.foo`和`proxy['foo']`
  - `set(target, propKey, value, receiver)`：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值
  - `has(target, propKey)`：拦截`propKey in proxy`操作，返回一个布尔值
  - `deleteProperty(target, propKey)`：拦截`delete prop[propKey]`操作，返回一个布尔值
  - `ownKeys(target)`：拦截`Object.getOenPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性
  - `getOwnPropertyDescriptor(target, propKey)`：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象
  - `defineProperty(target, propKey, propDesc)`：拦截`Object.defineProperty(target, propKey, propDesc)`、`Object.defineProperties(target, propDescs)`，返回一个布尔值
  - `preventExtensions(target)`：拦截`object.preventExtensions(proxy)`返回一个布尔值
  - `getProptotypeOf(target)`：拦截`Object.getPrototypeOf(proxy)`，返回一个对象
  - `isExtensible(target)`：拦截`Object.isExtensible(proxy)`，返回一个布尔值
  - `setPeototypeOf(target, proto)`：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。
  - `apply(target, object, proto)`：拦截`Proxy`实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`
  - `construct(target, args)`：拦截`proxy`实例作为构造函数调用的操作，比如`new proxy(...args)`

### Reflect

`Reflect`对象与`Proxy`对象一样也是`ES6`为了操作对象而提供地新`API`。`Reflect`对象设计的目的有这样几个

- 设计目的

  - 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`)，放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。

  - 修改某些`Object`方法方法返回的结果，让其变得合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`

    ```javascript
    //老写法
    try{
    	Object.defineProperty(target, property, attributes);
    	// success
    }catch(e){
    	// failure
    }
    
    //新写法
    if(Reflect.defineProperty(target, property, attributes)){
        // success
    }else{
        //failure
    }
    ```

  - 让`Object`属性都变成函数行为。某些`Object`操作是命令式，比如`name in obj`的`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为

    ```javascript
    // 老写法
    'assign' in Object  //true
    
    //新写法
    Reflect.has(Object, 'assign')   //true
    ```

  - `Reflect`对象的方法与`Proxy`对象的方法意义对应，只要是`Proxy`对象的方法就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管怎么修改默认行为，总可以在`Reflect`上获取默认行为

    ```javascript
    Proxy(target, {
        set: function(target, name, value, receiver){
        	var success = Reflect.set(target, name, value, receiver);
            if(success){
                console.log('property ' + name + ' on ' + target + ' set to ' + value);
            }
            return success;
        }
    })
    ```

    上面代码中，`Proxy`方法拦截`target`对象的属性赋值行为。它采用了`Reflect.set`方法将值赋给对象的属性，确保完成原有的行为，然后再部署额外的功能

- 静态方法，一共有13个

  - `Reflect.apply(target, thisArg, args)`
  - `Reflec.construct(target, args)`
  - `Reflect.get(target, name, receiver)`
  - `Reflect.set(target, name, value, receiver)`
  - `Reflect.defineProperty(target, name, desc)`
  - `Reflect.deleteProperty(target, name)`
  - `Reflect.has(target, name)`
  - `Reflect.ownKeys(target)`
  - `Reflect.isExtensions(target)`
  - `Reflect.preventExtensions(target)`
  - `Reflect.getOwnPropertyDescriptor(target, name)`
  - `Reflect.getPrototypeOf(target)`
  - `Reflect.setPrototypeOf(target, prototype)`

### `Generator + yield`

是`ES6`里面新的数据类型，像一个函数可以返回多次。特点是函数有个*号

调用的话就是不断调用`next()`，返回当前的`value`值和`done`的状态

`return`直接忽略所有的`yield`，返回最终结果

可以随心所欲的交出和恢复函数的执行权

### await和async

`async`函数就是将`Generator`函数的星号（*）替换成`async`，将`yield`替换成`await`

`async`函数对`Generator`函数的改进，体现在以下四点

- 内置执行器：`async`函数的执行和函数一模一样
- 更好的语义：`async`表示函数里有异步操作，`await`表示紧跟在函数后面的表达式需要等待结果
- 更广的适用性：`yield`命令后面只能是`Thunk`函数或`Promise`对象，而`async`函数的`await`命令后面，可以是`Promise`对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成`resolve`的`Promise`对象）
- 返回值是`Promise`：`async`函数的返回值是`Promise`对象，可以用`then`方法指定下一步的操作

## 正则表达式

[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions]('https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions')

## JS模块化

### 什么是模块化

模块化是一种规范，一种约束，这种约束会大大提升开发效率。将每个js文件看作是一个模块，每个模块通过固定的方式引入，并且通过固定的方式向外暴露指定的内容

### 模块化用来解决什么问题

- 全局变量污染：各个文件的变量都是挂载到window对象上，污染全局变量
- 变量重名：不同文件中的变量如果重名，后面的会覆盖前面的，造成程序运行错误
- 文件依赖顺序：多个文件存在依赖关系，需要保证一定的加载顺序

### Module模式

在模块化规范形成之前，JS开发者使用Module设计模式来解决JS全局作用域的污染问题。Module模式最初被定义为一种在传统软件工程中为类提供私有和公有封装的方法。在Javascript中，Module模式使用`匿名函数自调用（闭包）`来封装，通过自定义暴露行为来区分私有成员和公有成员

```js
let myModule = (function(window){
    let moduleName = 'module';   //private
    //public
    function setModuleName(name){
        moduleName = name;
    }
    //public
    function getModuleName(){
        return moduleName;
    }
    return {setModuleName, getModuleName};
})(window)
```

上面例子是Module模式的一种写法，它通过闭包的特性打开了一个新的作用域，它通过***闭包***的特性打开了一个新的作用域，缓解了全局作用域命名冲突的安全性的问题。但是，开发者并不能够用它来组织和拆分代码，于是乎便出现了以此为基石的模块化规范

### CommonJS

CommonJS主要用在Node开发上。每个文件就是一个模块，每个文件都有自己的一个作用域，通过`module.exports`暴露public成员，输出一个值的拷贝，输出之后不能改变，会缓存起来。所有的文件加载都是同步完成

```js
// 文件名：x.js
let x = 1;
function add(){
    x += 1;
    return x;
}
module.exports.x = x;
module.exports.add = add;
```

CommonJS通过`require()`引入模块依赖，require函数可以引入Node内置模块、自定义模块和npm第三方模块

```js
// 文件名main.js
let xm = require('./x.js');
console.log(xm.x);      //1
console.log(xm.add());  //2
console.log(xm.x);      //1，不是输出3，x只是一个值的拷贝
```

由于使用了Node的API，只能在服务端环境上运行

### AMD

一个单独文件一个模块，主要运行于浏览器端，模块和模块的依赖可以被异步加载。

1. 定义模块

AMD规范只定义了一个函数define，它是全局变量，使用`return`规范对外接口

```js
define(id?, dependencies, factory);
```

`id`：是定义中模块的名字，这个参数是可选的，如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字，如果提供了该参数，模块名必须是"顶级"和绝对的

`dependencies`：是定义的模块中所依赖的模块数组，依赖模块必须根据模块的工厂方法优先执行，并且执行的结果应该按照数组中位置顺序以参数的形式传入（定义中模块的）工厂方法中

`factory`：是模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次；如果是对象，此对象应该为模块的输出值

2. 加载模块

require.js中采用require()语句加载模块，使用require进行模块的加载

```js
require([module], callback);
```

`[module]`：是一个数组，里面的成员就是要加载的模块

`callback`：加载成功后的回调函数

3. requirejs使用例子

```js
// 定义一个math模块，返回一个add方法
define('math', ['jquery'], function($)){ //引入jquery模块
	return{
    	add: function(x, y){
    		return x + y;
		}   
    }
}

// 通过require加载math模块，使用math模块的add方法
require(['jquery', 'math'], function($, math){
    console.log(math.add(10, 100));     // 100
})
```

### CMD

一个文件一个模块。主要在浏览器中运行，define全局函数，定义模块，通过exports向外提供接口，用require获取接口，使用某个组件时用use()调用。通过require引入的模块，只有当程序运行到这里时候才会加载执行。

1. 定义模块

```js
define(factory);
```

define接受factory参数，factory可以是一个函数，也可以是一个对象或字符串

- factory为对象、字符串时：表示模块的接口就是该对象、字符串
- factory为函数时：表示模块的构造方法，执行该方法可以得到模块向外提供的接口，factory方法在执行时，默认会传入三个参数：`require`、`exports`、`module`。其中`require`用来加载模块，`exports`实现向外提供接口

```js
// factory为对象
define({"foo": "bar"});

// factory为字符串
define('I am a template. My name is {{name}}.');

// factory为函数
define(function(require, exports, module){
    //对外提供 foo 属性
    exports.foo = 'bar';
    //对外提供 doSomething 方法
    exports.doSomething = function(){}
})
```

2. 加载模块

当factory为函数时，require会作为默认参数传递进去，而require可以实现模块的加载

require是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口

```js
define(function(require, exports) {
  // 获取模块 a 的接口
  var a = require('./a');

  // 调用模块 a 的方法
  a.doSomething();
});
```

3. seajs使用例子

```js
//定义模块  myModule.js
define(function(require, exports, module){
    var $ = require('jquery.js');
    $('div').addClass('active');
    exports.data = 1;
});

//加载模块
seajs.use(['myModule.js'], function(my){
    var star = my.data;
    console.log(star);   // 1
})
```

### ES6模块化

ES6模块功能主要由两个命令构成： `import` 和`export` 。`import` 命令用于输入其他模块提供的功能。`export` 命令用于规范模块的对外接口。

1. export

```js
// 导出变量 profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1998;

// 导出函数 circle.js
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}
```

2. import

```js
import {firstName, lastName, year} form './profile.js'

function setName(element){
    element.textContent = firstName + ' ' + lastName;
}
```

```js
import * as circle form './circle.js'
console.log('面积：' + circle.area(4));
console.log('周长：' + circle.circumference(14))
```



# 网络

## 基础

### 网络分层体系

![img](https://201907.oss-cn-shanghai.aliyuncs.com/cs/5606289-263144780e3e6af6f1d3fcd145904919.png)

发送端从应用层→物理层 打包发送

接收端从物理层→应用层 解析获取

###  路由器工作在哪一层

- 网络层

  路由器是连接因特网中各局域网、广域网的设备，会根据信道的情况自动选择和设定路由，以最佳路径，按先后顺序发送信号

- 路由器和交换机最主要的区别就是**交换机发生在OSI参考模型的第二层（数据链路层）**，而**路由器发生在第三层（网络层）**

### `DNS`解析方式

以输入[www.google.com](www.google.com)为例

1. 浏览器检查自身缓存，有无解析此域名对应的`ip`
2. 操作系统缓存文件中查询
3. 请求本地域名服务器(`LDNS`)解析域名（一般在城市某处，不会太远）
4. 去根`DNS`域名服务器查询，此时会给出`.com`的顶级域名服务器
5. 去`.com`服务器查询，此时会给出`google.com`的地址，这是网站注册的域名服务器
6. 去`NameServer`查询，根据映射关系表找到目标`ip`，返回给`LDNS`（`LDNS`缓存域名及`ip`)
7. `LDNS`解析结果返回用户（缓存到系统缓存中），域名解析结束

## `TCP`与`UDP`

### `TCP`与`UDP`

- `UDP`是面向无连接的，不需要在正式传递数据之前先连接起双方，不保证有序且不丢失的传递到对端，并且`UDP`也没有任何流量控制的算法，一般可以用于直播、即时通讯、即时游戏等。基于`UDP`的应用层的协议有：`DNS`、`TFTP`（简单文件传输协议）、`RIP`（路由选择协议）、`DHCP`、`BOOTP`（是DHCP的前身）、`IGMP`（Internet组管理协议）
- `TCP`无论是建立连接还是断开连接都需要先进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，不如`UDP `高效。基于`TCP`的应用层的协议有：`SMTP`、`TELNET`、`HTTP`、`FTP`

### `TCP`建立连接-三次握手

起初，两端都为`CLOSED`状态。在通信开始前，双方都会建立`TCB`(Transmission Control Block *传输控制块*)，服务器创建完`TCB`后便进入`LISTEN`状态，开始等待客户端发送数据

- **第一次握手**：客户端向服务端发送连接请求报文段。该报文段包含自身的数据通讯初始序号。请求发送后，客户端进入`SYN-SENT`状态
- **第二次握手**：服务端接收到连接请求报文段后，如果同意连接，则会发送一个包含自身数据通讯初始序号的一个应答，发送完成后便进入`SYN-RECEIVED`状态
- **第三次握手**：当客户端收到同意连接的应答后，还要向服务端发送一个确认报文。客户端发送完这个报文段后便进入`ESTABLISHED`状态，服务端收到这个应答后也进入`ESTABLISHED`状态，此时连接建立成功

### 为什么`TCP`建立连接需要三次握手，明明两次就可以建立连接

**防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误**

`eg.` **加入只需要两次握手**，客户端发送了一个连接请求A，但是因为网络原因造成了超时，这是`TCP`会启动超时重传的机制再次发送一个连接请求B。此时请求顺利达到服务端，服务端应答完建立了请求，然后接收数据后释放了连接

假设这时连接请求A 在两端关闭后抵达了服务端，那么此时服务端会认为客户端又需要建立`TCP`连接，从而应答了该请求并进入`ESTABLISHED`状态。但是客户端其实是`CLOSED`状态，会导致服务端一直等待，造成资源浪费

### `TCP`断开连接-四次握手

刚开始的时候客户端和服务端是已经建立TCP连接的，FIN(请求关闭报文段)  ACK(确认请求报文段)

- **第一次握手**：客户端认为数据发送完成，向服务端发送释放连接请求
- **第二次握手**：服务端收到释放连接请求后，向客户端发送一个确认报文，并进入`CLOSE_WAIT`状态。此时表明客户端到服务端的连接已经释放，服务端不再接收客户端的数据，但此时服务端仍然可以发送数据给客户端
- **第三次握手**：服务端继续向客户端发送数据，完成后会向客户端发送连接释放请求，然后服务端进入`LAST_ACK`状态
- **第四次握手**：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入`TIME_WAIT`状态，该状态会持续2**MSL**（Maximum segment Lifetime *最大段生存期，指报文段在网络中生存的时间，超时会被抛弃*）时间，若该时间段内没有服务端的重发请求就进入`CLOSED`状态。当服务端收到确认应答后也进入`CLOSED`状态

### 为什么客户端要经过2**MSL**时间后才从`TIME_WAIT`状态进入`CLOSED`状态

- 为了保证客户端发送的最后一个ACK报文段能够达到服务器。 这个ACK报文段可能丢失，因而使处在`LAST-ACK`状态的服务器收不到确认。服务器会超时重传FIN+ACK报文段，客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重启计时器。如果客户端在`TIME-WAIT`状态不等待一段时间，而是再发送完ACK报文后立即释放连接，那么就无法收到服务器重传的FIN+ACK报文段，因而也不会再发送一次确认报文。这样，服务器无法按照正常步骤进入`CLOSED`状态。
- 防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个ACK确认报文段后，再经过时间2**MSL**，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### `TCP`如何解决数据丢包或报文顺序不对的问题？(未完成)

超时重传

### `TCP`如何实现流量控制的？（未完成）

滑动窗口

## `HTTP`协议

### HTTP报文格式

`HTTP`请求报文：请求行（`request line`）、请求头部（`header`）、空行、请求数据（`request data`)

![img](https://img-blog.csdn.net/20181012111654560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4X2VtaWx5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)     

- 请求行：请求方法、`URL`（包括参数信息）、协议版本等信息（ `GET /admin_ui/rdx/core/images/close.png HTTP/1.1` ）
- 请求头部：是一个个`key-value`值
- 空行（`CR+LF`)：请求报文用空行表示`header`和请求数据的分离
- 请求数据：`GET`方法没有携带数据，`POST`方法会携带一个`body`

`HTTP`响应报文： 状态行，响应头，空行，数据(响应体) 

![img](https://img-blog.csdn.net/20181012172656929?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4X2VtaWx5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 状态行：`HTTP`版本号、状态码和状态值组成
- 响应头：类似于请求头，是一系列`key-value`值
- 空白行：用来分隔`header`和数据
- 响应体：响应的`data`

### `HTTP`的几种请求方法用途

- `get`方法：发送一个请求来取得服务器上的某一资源
- `post`方法：向`URL`指定的资源提交数据或附加新的数据
- `put`方法：跟`post`很像也是向服务器提交数据，`put`指定了资源在服务器上的位置，`post`没有
- `head`方法：只请求页面的首部
- `delete`方法：删除服务器上的某资源
- `option`方法：获取当前`URL`所支持的方法。请求成功会有一个`Allow`的投包含类似`get,post`的信息
- `trace`方法：被用于激发一个远程的、应用层的请求消息回路
- `connect`方法：把请求连接转换到透明的`TCP/IP`通道

### `post`和`get`有什么区别？

- **用法上**：`get`一般用于无副作用、幂等的场景；`post`多用于有副作用、不幂等的场景
  - 幂等：发送M次和N次请求，服务器上资源状态一致
  - 副作用：副作用是指对服务器上的资源做出改变
- **本质上**：`get`和`post`都取决于`HTTP`。`HTTP`并没有要求`post`数据就要放在`body`中，也没有要求`get`就要把数据放在`URL`而不是`body`中
- **细节上**：
  - `get`能请求缓存，`post`不能
  - `post`支持更多的编码类型
  - `get`刷新/回退无害，`post`会再次提交
  - `get`能被保存为书签，`post`不可以
  - 由于浏览器`URL`有限制，所以`get`长度受限，但`post`不受限（因为在`body`里）

### `get`方法有没有请求体

`HTTP1.1`标准中并没有规定`get`方法是否可以有请求体，因此`get`方法是可以带请求体的，完全符合标准。`Elastic Search`中就是用`get`方法的请求体传递搜索条件，为了兼容性考虑，`Elastic Search`也接受`post`+请求体

### `get`和`post`的长度问题

`get`方法：理论上`get`请求数据长度是没有限制的，真正起到限制作用的是浏览器对其长度进行了限制

`post`方法：理论上`post`请求数据长度是没有限制的，真正起到限制作用的是服务器的处理能力

### `HTTP`常用请求头部

**通用**

- `cache-control`：控制缓存行为
- `connection`：连接的性质，比如`keep-alive`
- `user-Agent`： 用户信息，简称`UA`，是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、`CPU`类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。一些网站常常通过判断`UA`来给不同的操作系统、不同的浏览器发送不同的页面 
- `Date`：报文创建时间

**请求**

- `Referrer policy`：表示来源的（浏览器所访问的前一个页面），可以用于辅助检测`crsf`攻击，一般浏览器的默认值是`no-referere-when-downgrade`，意思是`https`降级`http`的时候不传原地址
- `Accept`：能正确接收的媒体类型
- `Accept-xx`**（Accept-Charset/Accept-Encoding/Accept-Language）**：能正确接收的xx
- `Expect`：期待服务端的指定行文
- `If-Match`：两端资源标记比较    
- `If-Modified-Since`：比较时间，未修改返回`304 Not Modified`
- `If-None-Match`：比较标记，未修改返回`304 Not Modified`

**响应**

- `Location`：重定向到某个`Location`
- `Server`：服务器名字
- `Age`：响应存在时间
- `Accept-Ranges`：可以接受的范围类型

#### `HTTP`请求中`connection = keep-alive`的意义在哪里

`HTTP`是基于`TCP`的，每一个`HTTP`请求都需要进行三次握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以`HTTP1.0`中出现了`connection = keep-alive`，用于建立长连接。`keep-alive`模式更加高效，因此避免了连接建立和释放的开销。但是长时间的`TCP`连接容易导致系统资源无效占用，配置不当的`keep-alive`有时比重复利用连接带来的损失更大。所以，正确设置`keep-alive`的`timeout`时间非常重要

### `HTTP`状态码

- **1XX**：信息状态码
  - `100 Continue`：客户端应重新发请求
  - `101 Switching Protocols`：改用协议`HTTP`换到`HTTPS`或者`HTTP1.1`换到`2.0`之类的
  - `105`：DNS解析失败
  
- **2XX**：成功状态码       
  - `200 OK`：操作成功
  - `201 Created`：按照客户端的请求创建了一个新资源
  - `202 Acceptd`：已接受请求但尚未处理
  - `204 No Content`：请求成功，但是报文不含实体的主体部分
  - `205 Reset Content`：请求成功，但是报文不含实体的主体部分，要求客户端重置内容
  - `206 Partial Content`：进行范围请求

- **3XX**：重定向
  - `301 Moved Permanetly`：永久性重定向，资源已经被分配到了新的`URL`
  - `302 Found`：临时重定向，资源临时分配了`URL`，实际上大部分客户端把它当成了**303**处理
  - `303 See Other`：表示资源存在另一个`URL`，应用`get`获取资源
  - `304 Not Modified`：允许访问资源，但实体主体为空（客户端已经有此数据，不需要再次发送）
  - `307 Temporary Redirect`：临时重定向，资源临时分配了`URL`，但是希望客户端能够保持方法不变请求新地址
- **4XX**：客户端错误
  - `400 Bad Request`：请求报文语法错误
  - `401 Unauthorized`：发送的请求需要通过验证，客户端试图操作一个受保护的资源但没有认证证书
  - `403 Forbidden`：请求资源存在但被拒绝，常用于一个资源只允许在特定时间段内访问
  - `404 Not Found`：找不到请求资源
  - `405 Method Not Allowed`：不支持的请求方法，比如只支持`get`，但是收到了`post`
- **5XX**：服务端错误
  - `500 Internal Server Error`：执行请求时发生错误
  - `501 Not Implemented`：不支持此请求方法（405是访问的资源不支持，501是服务器不能操作此方法）
  - `502 Bad Gateway`：代理与上行服务器之间出现问题
  - `503 Service Unavailable`：服务器暂时处于超负荷或者维护中

#### 状态码204的可能原因

- 服务器拒绝请求返回
- `get`资源存在但表示是空的。服务器通过这个状态码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素

#### 状态码204和205的区别

- 204和205的区别在于**205要求了重置**

  用一个表单为例，如果提交后返回204，那么表单里的各个字段值不变，可以继续修改他们；但假如得到的响应代码205，那么表单里的各个字段将被重置为它们的初始值

#### 状态码304的可能原因

这个与浏览器的协商缓存有关。

1. 当用户第一次请求资源A时，服务器会添加一个名为`Last-Modified`的响应头，这个响应头说明了A的**最后修改时间**，浏览器会把A的内容及最后的相应时间缓存下来
2. 当用户第二次请求资源A时，在请求中包含一个名为`If-Modified-Since`的请求头，它的值就是第一次请求时服务器通过`Last-Modified`响应头发送给浏览器的值，即资源A最后的修改时间
3. 服务器会获取`If-Modified-Since`的值，与**A当前的最后修改时间**做对比。如果相同，则服务器返回304状态码，表示A与浏览器上次缓存的时间相同，浏览器可以显示自己的缓存页面；如果不相同，说明A已经改变，服务器会返回200状态码

### `HTTP`协议中的长短连接和长短轮询

- **短连接**：即连接只保持在数据传输过程，请求发起、请求建立、数据返回、连接关闭。它适用于一些实时数据请求。
- **长连接**：即连接发起后，在请求关闭前客户端与服务器都保持连接，实质是保持这个连接通道，之后可以进行复用

* *短轮询*：指在循环周期内不断发起请求，每一次请求都立即返回结果，根据新旧数据对比决定是否使用这个结果
* *长轮询*：在请求的过程中若是服务器端数据没有更新则将这个连接挂起，直到服务器推送新的数据

#### 长短连接和长短轮询的区别

- **决定方式**：一个`TCP`是否为长连接是通过设置`HTTP`的`Connection Header`来决定的，而且需要两边都设置才有效；而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系
- **实现方式**：连接的长短是通过协议来规定和实现的。而轮询的长短是服务器通过编程的方式手动挂起请求来实现的

## `HTTP`与`HTTPS`

### `HTTP`为什么不安全

- 数据以明文传输，有被窃听的风险
- 接收到的报文无法证明是发送时的报文，不能保证完整性，报文有被篡改的风险
- 不能验证通信两端的身份，请求或响应有被伪造的风险

### `HTTP`与`HTTPS`有什么区别

- `https`协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

- `http`是超文本传输协议，信息是明文传输，`https`则是具有安全性的`SSL`(Secure Socket Layer)加密传输协议。

- `http`和`https`使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

- `http`的连接很简单，是无状态的；HTTPS协议是由`SSL`+`HTTP`协议构建的可进行加密传输、身份认证的网络协议，比`http`安全。

#### TLS(Secure Socket Layer)

**`HTTPS`**仍用`HTTP`传输信息，但信息通过`TLS`进行了加密，其间用到了两种加密技术。

- 对称加密：通信双方有相同的秘钥
- 非对称加密：数据公钥加密，私钥解密，私钥只有发出公钥的一方知道

`TLS`加密流程大致如下：

1. 服务器将公钥发散出去
2. 客户端创建对称加密的秘钥，用公钥加密后发送给服务器
3. 服务器用私钥解密
4. 之后客户端和服务器采用对称加密的方式进行数据传输

### `HTTPS`的缺点

- 通信两端都需要进行加密和解密，会消耗大量的CPU、内存等资源，增加了服务器的负担
- 加密运算和多次握手降低了访问速度
- 在开发阶段加大了页面调试难度。由于信息被加密了，所以用代理工具的话，需要先解密才能看到真实信息
- 用`HTTPS`访问的页面，页面内的外部资源都得用`HTTPS`请求，包括脚本中的`Ajax`请求

### `HTTPS`的单向认证和双向认证

- **单向认证**
  - 客户端保存着服务器的证书并信任改证书
  - `https`一般是单向认证，这样可以让绝大部分人访问该网点
- **双向认证**：一般用于企业应用对接
  - 需要有两个或两个以上证书，一个是服务器证书，其它是客户端证书
  - 服务器保存着客户端的证书并信任改证书，客户端保存着服务器的证书并信任该证书

## `HTTP2.0`

### `HTTP2.0`的新特性

`http2.0`是对`http1.0`的改进，相较于`htttp1.0`更快更高效

- **多路复用**：通过一个`TCP`连接传输所有数据。一个请求对应一个ID，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的id将请求再归属到各自不同的服务器端请求里面
- **二进制分帧层**：`HTTP2.0`性能增强的关键，它改变了通信两端交互数据的方式。原先是以文本传输，现在要先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对方接收帧并拼接成一条消息，再处理请求
- **首部压缩**：`HTTP1.X`的`header`带有大量信息，而且每次都需要重复发送，`HTTP2.0`使用`encoder`来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，又减小了传输大小
- **服务器推送**：`HTTP2.0`支持服务器主动推送，简单地说就是一次请求返回多个响应，这也是减少`HTTP`请求的方法。服务器出了处理最初的请求外，还会额外`push`客户端一定会请求的资源，无需客户端发出明确的请求

### `HTTP2.0`存在的问题

`http2.0`使用了多路复用，一般来说同一域名下只需要使用一个`TCP`连接。但是当连接中出现丢包时，整个`TCP`都要开始等待重传，后面的数据也都被阻塞了。而`http1.0`可以开启多个连接，只会影响一个，不会影响其他的

所以在**丢包情况下，http2.0的情况反而不如http1.0**

## `HTTP3.0`

为了解决2.0丢包性能的问题，Google基于`UDP`提出了`QUIC`协议。

### `QUIC`协议的特性

- **多路复用**：`QUIC`原始就包含此功能，并且传输的数据流可以保证有序教辅且不会影响其他数据流；其在移动端的表现也比`TCP`好，因为`TCP`基于**IP+端口识别**连接，不适合多变的网络环境，但是`QUIC`是通过**ID识别连接，不论网络如何变化，只要ID不变，就能迅速连上**
- **纠错机制**：假如说这次要发送三个包，协议会算出这三个包的异或值并单独发一个校验包，也就是总共发出了四个包。当出现其中医德非校验包丢失的情况时，可以通过另外三个包计算出丢失的数据包的内容。当然这种技术只能使用在丢失一个包的情况下，如果丢失多个包就只能使用重传的方式。
- **0-RTT**：通过使用类似`TCP`快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了

# 前后端数据交互

## 交互方式

### 1. Cookie

`Cookie`是一些数据，存储于电脑上的文本文件中，只要客户端`cookie`开放且有数据，每一次请求都会自动添加到`http`报文中，后台可以实时接收观察获取这些`cookie`

`Cookie`的作用就是解决"如何记录客户端的用户信息"

- 当用户访问`web`页面时，他的名字可以记录在`cookie`中
- 在用户下一次访问该页面时，可以再`cookie`中读取用户访问记录

### 2. Session

`Session`对象表示特定会话`session`的用户数据

用户第一次访问支持`session`的`JSP`网页时，服务器会创建一个`session`对象记录用户的信息，当用户访问同一网站的不同网页时，仍处于同一个`session`中

```java
request.getSession.setAttribute("sessionName", "sessionValue");
request.getSession.getAttribute("sessionName");
```

只要浏览器不关闭就能使用。所以用户访问网站的整个生命周期都会用到的数据一般都用`session`来存储，比如用户名、登录状态等

### 3. 利用Request参数设置

```java
request.setAttribute("requestName", "requestValue");
request.getRequest.Dispatcher("welcome.jsp").forward(request, response);

request.getAttribute("requestName");
```

不能用`sendRedirect()`，因为已经切换到另一个请求了，request参数的有效期为本次请求

### 4. Form表单

`Form`表单的`action`设置好路径

```html
<form id="loginform" name="looginform" action="<%=path %>/login" method="post">  </form> 
```

### 5. Ajax

- 原理：在用户和服务器之间加了—个中间层(` AJAX `引擎)，通过`XMLHttpRequest` 对象来向服务器发异步请求，从服务器获得数据，然后用`javascript`来操作`DOM` 更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据
- `Ajax` 的过程只涉及`JavaScript` 、` XMLHttpRequest` 和`DOM` 。` XMLHttpRequest` 是`ajax`的核心机制

```javascript
// 1. 创建连接
var xhr = null;
xhr = new XMLHttpRequest()
// 2. 连接服务器
xhr.open('get', url, true)
// 3. 发送请求
xhr.send(null);
// 4. 接受请求
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status == 200){
        	success(xhr.responseText);
        } else { // fail
        	fail && fail(xhr.status);
        }
    }
}
```

### cookie和session的对比

- cookie数据存放在客户的浏览器上，session数据放在服务器上。
- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。

- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。

- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

- 所以建议：
  - 将登录信息等重要信息存放为SESSION
  - 其他信息如果需要保留，可以放在COOKIE中

## 性能改进

### Comet

`Comet`的实现主要有两种方式，基于`ajax`的长轮询方式和基于`iframe`和`htmlfile`的流（http streaming）方式。而这些大部分功能都在后台完成，前端要做的就是通过`ajax`请求成功后，在`XMLHttpRequest`的`onReadystatechange`函数中持续获取数据。

典型 `ajax`通信方式也是`http`协议的经典使用方式，要想获得数据，首先得发送请求。在低延迟要求比较高的`web`应用中，只能增加服务器请求的频率。`Comet`则不同，**客户端与服务端保持一个长连接，只有客户端需要的数据更新时，服务器才主动将数据推送给客户端**

### SSE

SSE是一种允许服务端向客户端推送新数据的HTML5技术。它是 WebSocket 的一种轻量代替方案，使用 HTTP 协议。

严格地说，HTTP 协议是没有办法做服务器推送的，但是当服务器向客户端声明接下来要发送流信息时，客户端就会保持连接打

开，SSE 使用的就是这种原理

与由客户端每隔几秒从服务端轮询拉取新数据相比，这是一种更优的解决方案。

应用场景：例如邮箱服务的新邮件提醒，微博的新消息推送、管理后台的一些操作实时同步等

```js
var source=new EventSource("myevent");
source.onmessage=function(event){
console.log(event.data);
};
source.onerror=function(){
console.log("失败，连接状态"+source.readySate)
};
```

EventSource对象参数为入口点，必须与创建对象的页面同源(url模式，域、端口)。连接断开会自动建立,或者使用source.close()强

制断开。open事件在连接建立时触发，message事件在接收到新数据时触发，error事件在无法建立连接时触发。推送数据保存在

event.data中。

### WebSocket

Websocket是一个全新的、独立的协议，基于TCP协议，与http协议兼容、却不会融入http协议。他被设计出来的目的就是要取代

轮询和 Comet 技术。

WebSocket通过单个TCP连接提供全双工（双向通信）通信信道的计算机通信协议。此WebSocket API可在用户的浏览器和服务器

之间进行双向通信。用户可以向服务器发送消息并接收事件驱动的响应，而无需轮询服务器。 它可以让多个用户连接到同一个时

服务器，并通过API进行通信并立即获得响应。

```js
var socket=new WebSocket("url")；
	socket.send("hello world");
	socket.onmessage=function(event){
	console.log(event.data);
	console.log(event.readyState);
}
```

它允许用户和服务器之间的流连接，并允许即时信息交换。在聊天应用程序的示例中，通过套接字汇集消息，可以实时与一个或多

个用户交换，具体取决于谁在服务器上“监听”（连接）。

WebSockets适用于需要实时更新和即时信息交换的任何应用程序。一些示例包括但不限于：现场体育更新，股票行情，多人游戏，聊天应用，社交媒体等。

## 请求方式变化

### jquery ajax

JQuery ajax 是对原生XHR的封装，除此以外还增添了对JSONP的支持。

```js
window.onload=function(){
    var jsondata={
        "name":"Sarrans",
        "password":"123456"
    }
    $.ajax({
        type:"post",
        url:"login",
        data:jsondata,
        success:function(data){
        	alert(data.name+"请求成功");
        }
        error:function(e){
        	alert("Error");
        }
    })
}
```

缺点：

- 本身是针对MVC的编程,不符合现在前端MVVM的浪潮
- 基于原生的XHR开发，XHR本身的架构不清晰。
- JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案
  又不能享受CDN服务）
- 不符合关注分离（Separation of Concerns）的原则
- 配置和调用方式非常混乱，而且基于事件的异步模型不友好。

### fetch

fetch号称是A JAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计
的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，fetch不是ajax的进一步封
装，而是原生js，没有使用XMLHttpRequest对象。

```js
try {
    let response = await fetch(url);
    let data = response.json();
    console.log(data);
} catch(e) {
	console.log("Oops, error", e);
}
```

优点：

- 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
- 语法简洁，更加语义化
- 基于标准 Promise 实现，支持 async/await
- 同构方便，使用 isomorphic-fetch
- 脱离了XHR，是ES规范里新的实现方式
- 更加底层，提供的API丰富（request, response）

缺点：

- fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会
  reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
- fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
- fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能
- 阻止请求过程继续在后台运行，造成了流量的浪费
- fetch没有办法原生监测请求的进度，而XHR可以

### axios

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不
过它是Promise的实现版本，符合最新的ES规范。

```js
axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
.then(function (response) {
	console.log(response);
})
.catch(function (error) {
	console.log(error);
});
```

特点：

- 从浏览器中创建 XMLHttpRequest
- 支持 Promise API
- 客户端支持防止CSRF
- 提供了一些并发请求的接口（重要，方便了很多的操作）
- 从 node.js 创建 http 请求
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- 自动转换JSON数据

# 跨域

## 跨域的原因

当一个资源从与该资源本身所在服务器中不同域、协议、端口请求一个资源时，出于安全原因，浏览器限制从脚本内发起的跨源`HTTP`请求、`XMLHttpRequest`和`Fetch API`

引入这个机制主要是用来防止`CSRF`攻击的（利用用户的登录态发起恶意请求，跨域并不能完全阻止CSRF）。没有同源策略的情况下，A网站可以被任意其他来源的`ajax`访问到内容。如果用户当前在A网站还存在登录态，那么对方就可以通过`ajax`获得你的任何信息。

## 解决跨域的方式

### JSONP

- 原理：利用`<script>`标签没有跨域限制的漏洞

- 用法：通过`<script>`标签指向一个需要访问的地址并提供一个回调函数来接收数据

  ```javascript
  <script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
  <script>
  function jsonp(data) {
      console.log(data)
  }
  </script>
  ```

- 优点：使用简单且兼容性不错

- 缺点：只限于`get`请求

- 扩展：在开发过程中可能会遇到多个`JSONP`请求的函数的回调函数名是相同的，这时候需要手动封装一个`JSONP`，以下是简单实现

  ```javascript
  function jsonp(url, jsonpCallback, success) {
      let script = document.createElement('script')
      script.src = url
      script.async = true
      script.type = 'text/javascript'
      window[jsonpCallback] = function(data) {
      	success && success(data)
      }
      document.body.appendChild(script)
  }
  jsonp('http://xxx', 'callback', function(value) {
      console.log(value)
  })
  ```

### CORS（ Cross-Origin Resource Sharing，*跨域资源共享*）

- 原理：浏览器会自动进行`CORS`通信，只要后端实现了`CORS`，就实现了跨域
  - 服务端设置`Access-Control-Allow-Origin`就可以开启`CORS`，该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源
  - 前端发送请求时会出现两种情况，分别为**简单请求**和**预检请求**
    - 简单请求：简单`get`请求
    - 预检请求：规范要求对那些可能对服务器数据产生副作用的`HTTP`请求方法（特别是`get`以外的`http`请求或者搭配某些`MIME`类型的`post`请求），**浏览器必须先使用`OPTIONS`方法发起一个预检请求（`preflight request`），从而货值服务器是否允许该跨域请求。

### document.domain

该方法用于主域相同而子域不同的情况如：`a.test.com`和`b.test.com`

### iframe

具体操作可见：[iframe跨域操作](' https://www.cnblogs.com/happy-8090/p/11570998.html ')

- 用`iframe`的获取方式：只能显示，不能控制

  ```javascript
  a.location.hash
  b.window.name
  ```

- `iframe + postMessage`

  ```javascript
  window.postMessage(data, origin)
  ```

  子页面向父页面传递数据，则在子页面中调用父级`window`和`postMessage`

  ```javascript
  window.parent.postMessage=function(data, origin)
  ```



# 框架（未完成）

## MVC

  ![img](https://www.runoob.com/wp-content/uploads/2014/08/1200px-ModelViewControllerDiagram2.svg_.png) 

`M（Model）`：  模型 代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器 

`V（View）`： 视图代表模型包含的数据的可视化 

`C（Controller）`： 控制器作用于模型和视图上。它控制数据流向模型对象并在数据变化时更新视图。它使视图与模型分离开 

## MVP

![1584927856748](C:\Users\yangXM\AppData\Roaming\Typora\typora-user-images\1584927856748.png)

`M(model)`：业务逻辑层，主要负责数据、网络请求等操作

`V(View)`：视图层，负责绘制UI元素、与用户进行交互

`P(Presenter)`：是`View`与`model`交互的中间纽带，处理与用户交互的逻辑

## MVVM

![1584936997266](C:\Users\yangXM\AppData\Roaming\Typora\typora-user-images\1584936997266.png)

`M(Model)`：数据模型，也可以在Model中定义数据修改和操作的业务逻辑

`V(View)`：负责将数据模型转换成UI展现出来

`VM(ViewModel)`：同步View和Model的对象

在MVVM框架下，View和Model之间通过ViewModel进行交互，ViewModel通过数据双向绑定把View和Model曾连接了起来。View数据变化会同步到Model中，而Model数据变化也会立即反映到View上。因此开发者只需要关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理

对于MVVM来说最重要的不是通过双向绑定或者其他的方式将View和ViewModel绑定起来，***而是通过ViewModel将视图中的状态和用户的行为分理出一个抽象***。

## REACT

### 为什么要用React

解决了三个问题： 1.组件复用问题  2.性能问题  3.兼容性问题

优点：

- 只需查看 render 函数就会很容易知道一个组件是如何被渲染的

- JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的

- 支持服务端渲染，这可以改进 SEO 和性能

- 易于测试

- React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用

### 虚拟DOM

在浏览器端用`Javascript`实现的一套`DOM API`

### 为什么虚拟DOM会提高性能

虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。

具体实现步骤如下：

1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中；

2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异；

3. 将步骤2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。

### Diff算法

1. 把树形结构按照层级分解，只比较同级元素。

2. 给列表结构的每个单元添加唯一的key属性，方便比较。

3. React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）

4. 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.
5. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.

6. 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。

### React生命周期函数

**初始化阶段**

- `getDefaultProps`：获取实例的默认属性
- `getInitialState`：获取每个实例的初始化状态
- `componentWillMount`：组件即将被装载、渲染到页面上
- `render`：组件在这里生成虚拟的DOM节点
- `componentDidMount`：组件真正在被装载之后

**运行中状态**

- `componentWillReceiveProps`：组件将要接收到属性的时候调用

- `shouldComponentUpdate`：组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）

- `componentWillUpdate`：组件即将更新不能修改属性和状态

- `render`：组件重新描绘

- `componentDidUpdate`：组件已经更新

**销毁阶段**

- ` componentWillUnmount`：组件即将销毁 

### React性能优化方案

- 重写shouldComponentUpdate来避免不必要的dom操作。

- 使用 production 版本的react.js。

- 使用key来帮助React识别列表中所有子组件的最小变化

### React的 shouldComponentUpdate函数

 React虚拟dom技术要求不断的将dom和虚拟dom进行diff比较，如果dom树比较大，这种比较操作会比较耗时，因此React提供了shouldComponentUpdate这种补丁函数，如果对于一些变化，如果我们不希望某个组件刷新，或者刷新后跟原来其实一样，就可以使用这个函数直接告诉React，省去diff操作，进一步的提高了效率。 

###  (组件的)状态(state)和属性(props)之间有何不同？ 

- State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。

- Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。

###  当渲染一个列表时，何为 key？设置 key 的目的是什么？ 

 Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢 

###  (在构造函数中)调用 super(props) 的目的是什么？ 

 在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。 

###  何为 JSX ？ 

 JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React "元素"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。 

## VUE

### 对于Vue的理解

Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。

###  vue.js的两个核心是什么？ 

 数据驱动和组件化。 

###  vue生命周期钩子函数有哪些？ 

 总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。具体执行流程查看下图。 

 ![img](https://upload-images.jianshu.io/upload_images/21309003-59d002129320a1f5?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)

 ###  vue 的双向绑定的原理是什么？ 

 vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。具体实现过程： 

1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

2. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。

3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

流程图如下：

 ![img](https://upload-images.jianshu.io/upload_images/21309003-a088ac596b84d472?imageMogr2/auto-orient/strip|imageView2/2/w/785/format/webp)

###  请问v-if和v-show有什么区别？ 

相同点： 两者都是在判断DOM节点是否要显示。

不同点：

- 实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。 v-show只是在修改元素的css样式，也就是display的属性值，元素始终在Dom树上。

- 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； v-show只是简单的基于css切换；

- 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译； v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留；

- 性能消耗：v-if有更高的切换消耗，不适合做频繁的切换； v-show有更高的初始渲染消耗，适合做频繁的额切换；

###  v-on可以监听多个方法吗？ 

可以

###  vue中key值的作用 

使用key来给每个节点做一个唯一标识

**key的作用主要是为了高效的更新虚拟DOM**。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果

###  Vue 组件中 data 为什么必须是函数？ 

在new Vue()中，data是可以作为一个对象进行操作的，然而在component中，data只能以函数的形式存在，不能直接将对象赋值给它。

当data选项是一个函数的时候，每个实例可以维护一份被返回对象的独立的拷贝，这样各个实例中的data不会相互影响，是独立的。

###  v-for 与 v-if 的优先级 

 v-for的优先级比v-if高 

###  说出至少 4 种 vue 当中的指令和它的用法 

 v-if(判断是否隐藏)

 v-for(把数据遍历出来)

 v-bind(绑定属性)

 v-model(实现双向绑定)

###  vue中子组件调用父组件的方法 

第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法。

第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。

第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法。

###  vue中父组件调用子组件的方法 

父组件利用ref属性操作子组件方法。

```js
// 父
<child ref="childMethod"></child>
// 子
method: {
  test() {
    alert(1)
  }
}
```

在父组件里调用test即 this.$refs.childMethod.test()

###  vue组件之间传值(未完成)



###  怎么定义vue-router的动态路由？怎么获取传过来的值？ 

 动态路由的创建，主要是使用path属性过程中，使用动态路径参数，以冒号开头，如下： 

```js
{
    path: '/details/:id'
    name: 'Details'
    components: Details
}
```

访问details目录下的所有文件，如果details/a，details/b等，都会映射到Details组件上。

当匹配到/details下的路由时，参数值会被设置到this.$route.params下，所以通过这个属性可以获取动态参数this.$route.params.id

###  vue-router有哪几种路由守卫? 

路由守卫为：

全局守卫：beforeEach

后置守卫：afterEach

全局解析守卫：beforeResolve

路由独享守卫：beforeEnter

###  $route和 $router的区别是什么？ 

$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。

$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。

###  vue-router响应路由参数的变化

用`watch`检测

```js
watch: {
    $route(to, from){
        console.log(to.path);
    }
}
```

组件内导航钩子函数

```js
beforeRouteUpdate(to, from, next){
    // to do somethings
}
```

###  vue-router 传参 （未完成）

- 使用Params

  

 ## jQuery（未完成）

- 原因：`jQuery`是为了改变`javascript`的编码方式而设计的。
- 原理：
  - `jQuery`采用的是构造函数模式进行开发的,jQuery是一个类
  - `jQuery`的常用方法(CSS、属性、筛选、事件、动画、文档处理)都是定义在`jQuery.prototype`上的 ->只有`jQuery`的实例才能使用这些方法
- 核心：`jQuery`不仅仅是一个类(在它的原型上定义了很多的方法，每一个`jQuery`的实例都可以使用这些方法)，它还是一个普通的对象，在`jQuery`本身的属性中还增加了一系列的方法:`Ajax`、`each`、工具

## AngularJS（未完成）

## node（未完成）

- 定义：`Node`既不是一种语言，也不是一个框架，而是一个能执行`JavaScript`代码的运行时环境。

## webpack（未完成）

`WebPack`是一个模块打包工具，可以使用`WebPack`管理模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包`Web`开发中所用到的`HTML`、`Javascript` 、`CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源， `webpack`有对应的模块加载器。 `webpack`模块打包器会分析模块间的依赖关系，最后生成了优化且合并后的静态资源





# 浏览器

## 垃圾回收机制

**JavaScript 具有自动垃圾收集机制，就是找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）。常用的的方法有两种，即`标记清除`和`引用计数`**

### 引用计数

- 原理：一个对象不被其他对象引用时会被回收
- 问题：循环引用无法回收

### 标记清除

- 原理：从根元素（window对象）开始，周期性的标记可被访问的对象，同时回收不可被访问的对象
- 问题：收集垃圾时程序会等待，且回收后的内容空间不连续。于是出现了**标记-整理**机制，即回收后会整理内存空间，但效率又会降低一些

### 内存泄露

- **内存泄漏是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。**

- **闭包不会引起内存泄露**：由于IE9 之前的版本对JS对象和DOM对象使用不同的垃圾收集，从而导致内存无法进行回收。

- 什么操作会引起内存泄露：

  - 意外的全局变量

    ```javascript
    function leaks(){
    	leak = 'xxxx';   // 等价于 window.leak = 'xxxx';
    }
    // 或者由this创建的意外的全局变量
      function leaks(){
          this.leak = 'xxxx';
      }
      // leaks()调用自己，this指向window，而不是undefined
      leaks();
    ```
    
    ***解决方案：***在js文件头部加上'use strict'可以避免此类错误的发生
    
  - 被遗忘的计时器或回调函数
  
    ```js
    var someResource = getData();
    setInterval(function(){
    	var node = document.getElementById('node');
        if(node){
            // 处理node
            node.innerHTML = JSON.stringify(someResource);
        }
    }, 1000);
    ```
  
    如果后续`node`元素被删除，整个计时器其实没有任何作用。但如果没有回收定时器，整个定时器依然有效，不但定时器无法被内存回收，定时器中的依赖也无法被回收。
  
  - DOM引用
  
    ```js
    var elements = { 
        image: document.getElementById('image')};
    	function doStuff() { 
            elements.image.src = 'http://example.com/image_name.png';
        }
    	function removeImage() { 
            document.body.removeChild(document.getElementById('image'))
        }
    }
    ```
  
     即使我们对于 image 元素进行了移除，但是仍然有对 image 元素的引用，依然无法对其进行内存回收。 
  
  - 闭包
  
    ```js
    var theThing = null;
    var replaceThing = function () { 
    	var originalThing = theThing; 
        var unused = function () { 
            if (originalThing) 
                // 对于 'originalThing'的引用 
                console.log("hi"); 
        }; 
        theThing = { 
            longStr: new Array(1000000).join('*'), 
            someMethod: function () { 
                console.log("message"); 
            } 
        };
    };
    setInterval(replaceThing, 1000);
    ```
  
     这段代码，每次调用`replaceThing`时，`theThing`获得了包含一个巨大的数组和一个对于新闭包`someMethod`的对象。同时`unused`是一个引用了`originalThing`的闭包。 
  
     这个范例的关键在于，闭包之间是共享作用域的，尽管`unused`可能一直没有被调用，但是`someMethod`可能会被调用，就会导致无法对其内存进行回收。 当这段代码被反复执行时，内存会持续增长。 

## 浏览器存储机制

###  浏览器存储方式

- 存储方式：`cookie`、`localStorage`、`sessionStorage`、`indexDB`

- 区别如下表：

  |     特征     |              cookie              |       localStorage       | sessionStorage |         indexDB          |
  | :----------: | :------------------------------: | :----------------------: | :------------: | :----------------------: |
  | 数据生命周期 | 一般由服务器生成，可设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
  | 数据存储大小 |                4K                |            5M            |       5M       |           无限           |
  | 与服务端通信 |    每次请求都会携带在header中    |          不参与          |     不参与     |          不参与          |

- 如果处于性能考虑，如果没有大量数据存储要求的话，可以使用`localStorage`和`sessionStorage`。对于不怎么改变的数据尽量使用`localStorage`存储，否则可以用`sessionStorage`存储。

### cookie的属性和使用

- 属性及作用如下表所示：

|   属性    |                             作用                             |
| :-------: | :----------------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |           不能通过`js`访问`cookie`，减少`XSS`攻击            |
|  secure   |               只能在协议为`HTTPS`的请求中携带                |
| same-site |    规定浏览器不能在跨域请求中携带`Cookie`，减少`CSRF`攻击    |

- 使用：`cookie`的各种参数用字符串拼接，最后保存到一个变量中，用`document.cookie`设置

  ```javascript
  document.cookie = cookie
  ```

## 浏览器缓存机制

缓存是浏览器性能优化中简单高效的一种方式，可以**显著减少网络传输带来的损耗**

### 缓存位置

缓存从位置上来说可以分为四种，并且有各自的优先级。**当多次查找缓存都没有命中的时候，才会请求网络**。顺序是：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache
5. 网络请求

#### Service Worker

它的缓存机制与浏览器其它内建缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且是连续性的

当Service Worker没有命中缓存的时候，会根据缓存优先级去查找数据。但是**不管我们是从Memory Cache中还是从网络请求中获取的数据，浏览器都会显示我们是从Service Worker中获取的内容**

#### Memory Cache

存储在内存中的缓存，读取内存中数据速度比磁盘快。**虽然效率高，但是缓存持续性很短，会随着进程的释放而释放。**一旦我们关闭tab页面，内存中的缓存也就被释放了

#### Disk Cache

存储在硬盘上的缓存。与Memory Cache相比，速度会慢一些，但是胜在容量和存储时效性上

在所有浏览器缓存中，Disk Cache 覆盖面积是最大的。它会根据HTTP Header中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据

#### Push Cache

是HTTP/2 中的内容，当以上三种缓存都没有命中时才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就会被释放

#### 网络请求

如果所有缓存都没有命中的话，就会发起请求来获取资源

### 缓存策略

**强值缓存**

- Expires：HTTP1.0中的内容。受限于本地时间，如果修改了本地时间，可能会造成缓存失效
- Cache-control：HTTP1.1中的内容，优先级比Expires高，可以在请求头或者响应头中设置

**协商缓存**（比较缓存）

- Last-Modified和If-Midified-Since

  - 原理：Last-Modified 表示资源的最后修改日期，If-Modified-Since会将Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话会将新的资源发送回来，否则返回304状态码
  - 缺点：1. 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成Last-Modified被修改。2. Last-Modified只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确资源

- ETag和If-None-Match

  ETag类似于文件指纹，If-None-Match会将当前ETag发送给服务器，询问该资源ETag是否变动，有变动的话就将新的资源发送回来。并且ETag的优先级比Last-Modified要高

#### 总结

**强制缓存**：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求直接用缓存，不在时间内，执行协商缓存策略

**协商缓存**：将缓存信息的Etag和Last-Modified通过请求发送给服务器，有服务器校验，返回304状态码时，浏览器直接用缓存

## 浏览器渲染机制

### 渲染机制

1. 创建DOM树：用HTML分析器，分析HTML元素，构建一棵DOM树

2. 创建Style Rules：用CSS分析器，分析CSS文件和元素上的inline样式，生成页面样式表

3. 构建render树：将上面的DOM树和样式表关联起来，生成一棵Render树。这一过程又叫Attachment。每个DOM节点都有attach方法，接受样式信息，返回一个render对象（又叫renderer）。这些render对象最终被构建成一棵render树

4. 布局Layout：浏览器为每个render树上的节点确定一个在显示屏上出现的精确坐标

5. 绘制painting：调用paint方法，显示在显示屏上

### 什么情况会阻塞渲染

- 渲染的前提是生成渲染树，所以HTML和CSS肯定会阻塞渲染

  想渲染的越快，越应该降低一开始需要渲染的大小，并且做到HTML扁平层级，优化CSS选择器

- 一般当浏览器解析到`script`标签时会暂停构建DOM，完成后才会从暂停的地方重新开始

  建议将`script`标签放在`body`标签底部

### script标签一定会阻塞渲染吗

**不一定**

- 将`script`标签放在`body`标签底部

- `defer`属性：加载后续文档元素的过程将和`js`文件的***加载***并行进行，但是`js`的执行要在素有元素解析完成之后，`DOMContentLoaded`事件触发之前进行。
- `aysnc`属性：加载和渲染后序文档的过程将和`js`的***加载与执行***并行进行

### 重绘和回流

- 重绘：当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘
- 回流：当渲染树的一部分或者全部元素因改变了自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流

**回流必定会发生重绘，重绘不一定会引发回流**

#### 那些问题可能会导致重绘和回流

- 改变window大小
- 改变字体
- 改变字体
- 添加和删除样式
- 文字改变
- 定位或者浮动
- 盒模型

#### 如何减少重绘和回流

- 用transform 代替 top，left ，margin-top， margin-left... 这些位移属性
- 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流
- 不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之。如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置
- 不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight... 这些
- 不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局
- 对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签
- 必要时可以开启 GPU 加速，但是不能滥用

## 浏览器性能优化

### DOMContentLoad和Load

- `DOMContentLoad`：事件触发时，仅当DOM加载完成，不包括样式表、图片
- `Load`：事件触发时，页面上的所有的DOM、样式表、脚本、图片都已加载完成

### 为什么CSS要放在head里面

- 构建render树需要DOM和CSSOM（style rules），所以HTML和CSS都会阻塞渲染，所以需要CSS尽早加载以缩短首次渲染的时间
- 由于CSS不会阻塞文档解析，但是会阻塞文档渲染。把CSS放在头部可以先生成CSSOM树，后续渲染DOM的时候，可以一次性构建Render树；如果把CSS放在后面，会先解析一次DOM，加载CSS之后，会重新渲染之前的DOM，需要两次渲染

### 为什么JS要放在body标签底部

- 阻塞浏览器的解析。也就是说发现另一个脚本时，需等待脚本下载完成并执行完成后才会继续解析HTML
- 普通的脚本会阻塞浏览器解析，加上`defer`或`async`属性，脚本就会变成异步
- 执行`JS`代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑用`Web Worker`，它可以让我们另开一个线程执行脚本，不影响渲染

### 白屏 首屏

- 白屏

  - 浏览器开始显示内容的时间，一般认为浏览器开始渲染`body`或者解析完`head`标签的时候是白屏结束的时间

  - 计算方法：

    1. IE8：title后输出一个时间`pagestarttime`

    2. head结束前输出一个时间`firstpaint`

       白屏时间 = firstpaint - pagestarttime / performance.timing.navigationstart

  - 优化：

    - 加快`JS`执行速度，比如无限滚动的页面，可以先用`JS`渲染一个屏幕范围内的东西
    - 减少文件体积
    - 首屏同步渲染html，后序的滚屏再异步加载和渲染

- 首屏

  - 用户打开网站开始，到浏览器首屏内容渲染完成的时间
  - 计算方法：
    - 模块标签标记：适用于内容不需要拉取数据才能生存以及页面不考虑图片等资源的加载情况。结束位置加时间戳输出时间
    - 统计首屏内图片加载最慢时间。
    - 自定义计算
  - 优化：
    - 首屏数据拉取逻辑放在顶部
    - 首屏渲染CSS及JS逻辑优先内联html，返回时能立即执行
    - 次屏逻辑延后执行

- 整页时间：整个页面加载完成时间。`loadEvntEnd-navigationStart/onload`记录时间戳

### 防抖和节流

- 防抖：将多次执行变为最后一次执行

  ```javascript
  const debounce = (func, wait = 50) => {
      let timer = 0;
      return function(...args){
          if(timer) cleatTimeout(timer);
          timer = setTimeout(() => {
              func.apply(this, args);
          }, wait)
      }
  }
  ```

- 节流：将多次操作变成每隔一段时间执行

  ```javascript
  function throttle(func, wait){
      let last;
      return function(...args){
          let new += new Date();
          if(!last || now > last + wait){
              last += now;
              func.apply(this, args);
          }
      }
  }
  ```

### 预渲染

通过预渲染**将下载的文件预先在后台渲染**，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http;//example.com">
```

预渲染虽然可以提高页面的加载速度，但是**要确保该页面大概率会被用户在之后打开**，否则就是白白浪费资源去渲染。

### 懒执行

懒执行是**将某些逻辑延迟到使用时再计算**

该技术可以用于首屏优化，对于某些耗时且逻辑不需要在首屏就使用的，就可以使用懒执行

懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒

### 懒加载

懒加载就是**将不关键的资源延后加载**

懒加载的原理就是就是只加载自定义区域（通常是可执行区域，但也可以是即将进入可视区域）内需要加载的东西

对于图片来说，先设置图片标签`src`属性为一张占位图，将真实的图片放入一个自定义属性中，当进入自定义区域时，九江自定义属性替换为`src`属性，这样图片就会去下载资源，实现了图片的懒加载

懒加载不仅可以用于图片，也可以用在别的资源上，比如进入可视区域才开始播放视频等等

### CDN（Content Delivery Network，内容分发网络）

`CDN`的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源

### 硬件加速

#### 让一个元素左移100px，使用left和transform有什么区别？

使用left等属性来设置动画会一直触发浏览器的重绘，而使用CSS3中国的transform会采用GPU硬件加速，不触发重绘，性能更好

#### 硬件加速的原理

DOM树和CSSOM合并后形成Render树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理。GPU中的transform是不会触发重绘的，这一点非常类似3D绘图功能。最终这些使用tranform的图层都会由独立的合成器进程进行处理。

总结：

**CSS3 transform创建了一个新的复合图层，可以被GPU直接用来执行transform，从而不触发浏览器的重绘来达到加速的目的**

以下情况会创建一个独立的复合图层：

- 3D或者CSS transform
- <videl> 和<canvas> 标签
- CSS filters
- 元素覆盖时，比如用了z-index属性

#### 如何硬件加速

以下CSS属性可以触发硬件加速：

- transform
- opacity
- filter
- will-change:告知浏览器哪一个属性即将变化

还可以通过transform的3D属性强制开始GPU加速使用

```css
transform:translateZ(0);
transform:rotateZ(360deg);
```

#### 使用硬件加速的注意事项

- 不能让每个元素都启用硬件加速，这样会占用很大的内存，使页面有很强的卡顿感
- GPU渲染会影响字体的抗锯齿效果，这是因为GPU和CPU具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。

# WEB安全

## SQL注入

### 原理

通过把`SQL`命令插入到`WEB`表单递交或插入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意`SQL`的命令

### 防范

- 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式或者限制长度，对单双引号和'-'进行转义
- 永远不要动态拼装`SQL`，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取
- 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
- 不要把机密信息明文存放，请加密或者`hash`掉密码和敏感的信息

## XSS（cross-site scripting）跨站脚本攻击

### 原理

指的是攻击者往`WEB`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中加一个恶意表单，骗取用户点击后，窃取`cookie`中用户的私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点

### 防范

- 用户输入的地方和变量都需要仔细检查长度
- 对尖括号、引号、分号等进行转义
- 任何内容写到页面之前都必须加以`encode`
- `CSP`白名单

## CSRF（cross-site request forgery）跨站请求伪造

### 原理

攻击者通过一些技术手段欺骗用户的浏览器去访问用户曾经认证过的网站并执行一些操作（如发送邮件、发消息、甚至财产操作如转账和购买商品等）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了`web`登录身份认证的一个漏洞：**简单的认证只能保证请求来自用户的浏览器，但不能识别请求是用户自愿发出的**

### 防范

- `get`请求不对数据进行修改
- 不让第三方网站访问到用户`cookie`：对cookie设置SameSite属性，该属性表示`cookie`不随着跨域请求发送
- 阻止第三方网站请求接口：通过验证`referer`来判断请求是否为第三方网站发起的
- 请求是附带验证信息，比如验证码或者`token`

## 点击劫持

### 原理

是一种**视觉欺骗**的攻击手段。攻击者将需要被攻击的网站通过`iframe`嵌套的方式嵌入自己的网页中，并将`iframe`设置为透明，在页面中透出一个按钮又到用户点击

### 防范

- **设置HTTP头：X-FRAME-OPTIONS**

  这个HTTP响应头就是为了防御用`iframe`嵌套的点击劫持

  该响应头有三个值，分别为

  - `DENY`：表示页面不允许通过`iframe`的方式展示
  - `SAMEORIGIN`：表示页面可以再相同域名下通过`iframe`的方式展示
  - `ALLOW-FROM`：表示页面可以再指定来源的`iframe`中展示

- **JS防御**

  当通过`iframe`的方式加载页面时，攻击者的网页直接不显示所有内容了

  ```html
  <head>
      <style id="click-jack">
      html {
      	display: none !important;
      }
      </style>
  </head>
  <body>
  <script>
      if (self == top) {
      	var style = document.getElementById('click-jack')
      	document.body.removeChild(style)
      } else {
      	top.location = self.location
      }
  </script>
  </body
  ```

  

## 中间人攻击

### 原理

**攻击者同时与服务器和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。**攻击者不仅能获得双方的通信信息，还能修改通信信息

### 防范

防御中间人攻击其实并不难，只**需要增加一个安全通道来传输信息**。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。







